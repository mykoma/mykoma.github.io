<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>成都老刘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wwhy.tech/"/>
  <updated>2018-08-02T15:50:46.151Z</updated>
  <id>http://wwhy.tech/</id>
  
  <author>
    <name>Gang Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Specta单元测试检测View和ViewController是否泄漏</title>
    <link href="http://wwhy.tech/2018/08/02/2018-08-02/"/>
    <id>http://wwhy.tech/2018/08/02/2018-08-02/</id>
    <published>2018-08-02T12:00:00.000Z</published>
    <updated>2018-08-02T15:50:46.151Z</updated>
    
    <content type="html"><![CDATA[<h3>序</h3><p>前面<a href="http://wwhy.tech/2018/07/28/2018-07-28/">使用Specta单元测试检测对象是否泄漏</a>介绍了如何检测一个普通的NSObject对象是否泄漏。UIView和UIViewController也是NSObject的子类，当然也能使用<a href="http://wwhy.tech/2018/07/28/2018-07-28/">使用Specta单元测试检测对象是否泄漏</a>，但是我们知道UIView和UIViewController的应用场景比起普通的NSObject对应要更加复杂一些。</p><p>下面会介绍使用Specta单元测试检测View和ViewController是否泄漏。</p><h4>TestContainer 代码</h4><p>和之前的文章一样，也需要一个TestContainer来weak持有要检测的对象。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface TestContainer : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id object;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation TestContainer</span><br><span class="line">// Empty</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h4>UIView的检测</h4><p>对于UIView的检测，我们可以创建一个UIWindow，并且把UIView添加到这个UIWindow里面，然后让这个UIWindow进行展示，最后再将这个UIWindow设置成nil，这样就能模拟这个UIView一个完整的生命周期。</p><p>这样就能检测UIView是否存在泄漏。</p><h5>UIView - Spec测试代码</h5><p>下面写检测代码，我们定义一个局部变量weakView， 然后在一个@autoreleasepool里面创建对象， 并且这个weakView在block内部置为nil</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">describe(@&quot;TestObject&quot;, ^&#123;</span><br><span class="line">    context(@&quot;when created&quot;, ^&#123;</span><br><span class="line">        it(@&quot;should dealloc&quot;, ^&#123;</span><br><span class="line">            TestContainer *tc = [TestContainer new];</span><br><span class="line">            __weak TestView *weakView = nil;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                TestView *view = [[TestView alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span><br><span class="line">                expect(view).beKindOf([UIView class]);</span><br><span class="line">                UIWindow *window = [[UIWindow alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span><br><span class="line">                [window makeKeyAndVisible];</span><br><span class="line">                [window addSubview:view];</span><br><span class="line">                weakView = view;</span><br><span class="line">                expect(weakView).notTo.beNil();</span><br><span class="line">                tc.object = weakView;</span><br><span class="line">                view = nil;</span><br><span class="line">                window = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            expect(tc.object).after(5).to.beNil();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里我们断言：断定tc的object指针在5秒钟后，是nil。</p><h5>UIView - 模板代码</h5><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sharedExamplesFor(@&quot;view_dealloc_behavior&quot;, ^(NSDictionary *data) &#123;</span><br><span class="line">    context(@&quot;removed&quot;, ^&#123;</span><br><span class="line">        it(@&quot;should dealloc&quot;, ^&#123;</span><br><span class="line">            id (^block)(void) = [[data allValues] firstObject];</span><br><span class="line">            if (!block) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            TestContainer *tc = [TestContainer new];</span><br><span class="line">            __weak UIView *weakView = nil;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                UIView *view = block();</span><br><span class="line">                expect(view).beKindOf([UIView class]);</span><br><span class="line">                UIWindow *window = [[UIWindow alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span><br><span class="line">                [window makeKeyAndVisible];</span><br><span class="line">                [window addSubview:view];</span><br><span class="line">                weakView = view;</span><br><span class="line">                expect(weakView).notTo.beNil();</span><br><span class="line">                tc.object = weakView;</span><br><span class="line">                view = nil;</span><br><span class="line">                window = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            expect(tc.object).after(5).to.beNil();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>使用上面的模板代码，</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(@&quot;TestView&quot;, ^&#123;</span><br><span class="line">    itShouldBehaveLike(@&quot;view_dealloc_behavior&quot;, @&#123; @&quot;value&quot; : ^&#123;</span><br><span class="line">        return [[TestView alloc] init];</span><br><span class="line">    &#125; &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5>检测结果</h5><p>在Xcode中，按<code>Command + U</code>开始测试，上面代码中， 我们运行的结果是 <code>Test Success</code></p><h4>UIViewController的检测</h4><p>对于UIViewController的检测，我们同样可以创建一个UIWindow，并且把UIViewController设置为这个UIWindow的rootViewController，同样然后让这个UIWindow进行展示，最后再将这个UIWindow设置成nil，同样也就能模拟这个UIViewController一个完整的生命周期。</p><p>这样就能检测UIViewController是否存在泄漏。</p><h5>UIViewController - Spec测试代码</h5><p>下面写检测代码，我们定义一个局部变量weakView， 然后在一个@autoreleasepool里面创建对象， 并且这个weakView在block内部置为nil</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">describe(@&quot;TestObject&quot;, ^&#123;</span><br><span class="line">    context(@&quot;when created&quot;, ^&#123;</span><br><span class="line">        it(@&quot;should dealloc&quot;, ^&#123;</span><br><span class="line">            TestContainer *tc = [TestContainer new];</span><br><span class="line">            __weak TestViewController *weakController = nil;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                TestViewController *controller = [[TestViewController alloc] init];</span><br><span class="line">                expect(controller).beKindOf([UIViewController class]);</span><br><span class="line">                UIWindow *window = [[UIWindow alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span><br><span class="line">                [window makeKeyAndVisible];</span><br><span class="line">                [window setRootViewController:controller];</span><br><span class="line">                weakController = controller;</span><br><span class="line">                expect(weakController).notTo.beNil();</span><br><span class="line">                tc.object = weakController;</span><br><span class="line">                controller = nil;</span><br><span class="line">                window = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            expect(tc.object).after(5).to.beNil();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里我们断言：断定tc的object指针在5秒钟后，是nil。</p><h5>UIViewController - 模板代码</h5><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sharedExamplesFor(@&quot;viewController_dealloc_behavior&quot;, ^(NSDictionary *data) &#123;</span><br><span class="line">    context(@&quot;removed&quot;, ^&#123;</span><br><span class="line">        it(@&quot;should dealloc&quot;, ^&#123;</span><br><span class="line">            id (^block)(void) = [[data allValues] firstObject];</span><br><span class="line">            if (!block) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            TestContainer *tc = [TestContainer new];</span><br><span class="line">            __weak UIViewController *weakController = nil;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                UIViewController *controller = block();</span><br><span class="line">                expect(controller).beKindOf([UIViewController class]);</span><br><span class="line">                UIWindow *window = [[UIWindow alloc] initWithFrame:CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height)];</span><br><span class="line">                [window makeKeyAndVisible];</span><br><span class="line">                [window setRootViewController:controller];</span><br><span class="line">                weakController = controller;</span><br><span class="line">                expect(weakController).notTo.beNil();</span><br><span class="line">                tc.object = weakController;</span><br><span class="line">                controller = nil;</span><br><span class="line">                window = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            expect(tc.object).after(5).to.beNil();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>使用上面的模板代码，</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(@&quot;TestViewController&quot;, ^&#123;</span><br><span class="line">    itShouldBehaveLike(@&quot;viewController_dealloc_behavior&quot;, @&#123; @&quot;value&quot; : ^&#123;</span><br><span class="line">        return [[TestViewController alloc] init];</span><br><span class="line">    &#125; &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h5>检测结果</h5><p>在Xcode中，按<code>Command + U</code>开始测试，上面代码中， 我们运行的结果是 <code>Test Success</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;序&lt;/h3&gt;
&lt;p&gt;前面&lt;a href=&quot;http://wwhy.tech/2018/07/28/2018-07-28/&quot;&gt;使用Specta单元测试检测对象是否泄漏&lt;/a&gt;介绍了如何检测一个普通的NSObject对象是否泄漏。UIView和UIViewController
      
    
    </summary>
    
    
      <category term="测试" scheme="http://wwhy.tech/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Specta单元测试检测对象是否泄漏</title>
    <link href="http://wwhy.tech/2018/07/28/2018-07-28/"/>
    <id>http://wwhy.tech/2018/07/28/2018-07-28/</id>
    <published>2018-07-28T12:00:00.000Z</published>
    <updated>2018-07-28T13:34:43.322Z</updated>
    
    <content type="html"><![CDATA[<h3>序</h3><p>Specta作为一个优秀的测试框架，不仅能够进行常规的单元测试，也能够测试对象是否存在泄漏。</p><h4>原理</h4><p>创建一个容器TestContainer，它weak持有将要检测的对象testObject，然后，我们让其他持有testObject的指针都置为nil，这样就只有这个容器TestContainer在weak持有testObject，我们知道没有强引用这个testObject的时候，testObject的对象会被释放掉， 而TestContainer里面weak引用的指针，也会被置为nil。</p><p>而我们会延时几秒钟，检查TestContainer的指针是不是为nil。</p><h4>具体操作</h4><h5>TestContainer 代码</h5><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface TestContainer : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id object;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation TestContainer</span><br><span class="line">// Empty</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>最后我们会延时TestContainer的object指针是不是为nil。</p><h5>要检测的对象 代码</h5><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface TestObject : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestObject</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5>Spec测试代码</h5><p>下面写检测代码，我们定义一个局部变量testObj， 然后在一个@autoreleasepool里面创建对象， 并且这个testObj在block内部置为nil</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">describe(@&quot;TestObject&quot;, ^&#123;</span><br><span class="line">    context(@&quot;when created&quot;, ^&#123;</span><br><span class="line">        __block TestObject *testObj = nil;</span><br><span class="line">        it(@&quot;should be dealloc when not use&quot;, ^&#123;</span><br><span class="line">            TestContainer * tc = [TestContainer new];</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                testObj = [TestObject new];</span><br><span class="line">                tc.object = testObj;</span><br><span class="line">                testObj = nil;</span><br><span class="line">            &#125;;</span><br><span class="line">            expect(tc.object).after(5).to.beNil();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里我们断言：断定tc的object指针在5秒钟后，是nil。</p><h5>检测结果</h5><p>在Xcode中，按<code>Command + U</code>开始测试，上面代码中， 我们运行的结果是 <code>Test Success</code></p><h5>修改代码</h5><p>我们故意修改TestObject代码， 让其不能正常释放。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface TestObject : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestObject</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.timer = [NSTimer timerWithTimeInterval:1</span><br><span class="line">                                             target:self</span><br><span class="line">                                           selector:@selector(timerAction)</span><br><span class="line">                                           userInfo:nil</span><br><span class="line">                                            repeats:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)timerAction &#123;</span><br><span class="line">    NSLog(@&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h5>检测结果2</h5><p><code>Test Fail</code></p><h4>更加模板化一点的用法</h4><p>从上面的代码中，如果您按照上面的操作进行测试，能够发现我们能够检测对象是否正常释放。</p><p>在实际项目中，我们知道我们要测试的对象会有很多， 除了上面的检测代码外， 我们想要的会更多。</p><p>作为一个程序员， 想的是如何能够更加简单化！！！</p><h5>写Spec模板代码</h5><p>利用sharedExamplesFor模板化</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sharedExamplesFor(@&quot;dealloc_behavior&quot;, ^(NSDictionary *data) &#123;</span><br><span class="line">    context(@&quot;release&quot;, ^&#123;</span><br><span class="line">        it(@&quot;should dealloc&quot;, ^&#123;</span><br><span class="line">            id (^block)(void) = [[data allValues] firstObject];</span><br><span class="line">            if (!block) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            TestContainer *container = [TestContainer new];</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                id object = nil;</span><br><span class="line">                __weak id weakObject = nil;</span><br><span class="line">                object = block();</span><br><span class="line">                weakObject = object;</span><br><span class="line">                expect(weakObject).notTo.beNil();</span><br><span class="line">                container.object = weakObject;</span><br><span class="line">                object = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            expect(container.object).after(5).beNil();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里需要注意的是sharedExamplesFor的第一个参数@&quot;dealloc_behavior&quot;，会在下面使用。</p><h5>Spec测试代码</h5><p>调用sharedExamplesFor模板化的代码</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">describe(@&quot;TestObject&quot;, ^&#123;</span><br><span class="line">    itShouldBehaveLike(@&quot;dealloc_behavior&quot;, @&#123; @&quot;value&quot; : ^&#123;</span><br><span class="line">        return [[TestObject alloc] init];</span><br><span class="line">    &#125; &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注意itShouldBehaveLike的第一个参数， 这个参数就是上面记录的@&quot;dealloc_behavior&quot;。</p><p>这样就每次使用5行代码， 就能够检测对象是否被正常释放。</p><h4>更进一步</h4><p>这里我们只是检测了这个对象testObj是否正常释放，但是有时这个对象testObj里面新生成了对象innerObj，可能这个testObj正常释放了， 但是innerObj却没有释放。</p><p>当然我们可以单独检测innerObj是否正常释放，不过更方便有效的是，我们能够遍历检测testObj里面的子对象，把所有的对象都检测一边。这样就能够更加高效一点的检测对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;序&lt;/h3&gt;
&lt;p&gt;Specta作为一个优秀的测试框架，不仅能够进行常规的单元测试，也能够测试对象是否存在泄漏。&lt;/p&gt;
&lt;h4&gt;原理&lt;/h4&gt;
&lt;p&gt;创建一个容器TestContainer，它weak持有将要检测的对象testObject，然后，我们让其他持有testO
      
    
    </summary>
    
    
      <category term="测试" scheme="http://wwhy.tech/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>React Native 中Component和PureComponent总结</title>
    <link href="http://wwhy.tech/2018/07/19/2018-07-19/"/>
    <id>http://wwhy.tech/2018/07/19/2018-07-19/</id>
    <published>2018-07-19T02:11:00.000Z</published>
    <updated>2018-07-19T08:34:00.917Z</updated>
    
    <content type="html"><![CDATA[<h3>序</h3><p>在客户端上，iOS和React的页面概念是不一样的。在React中，Component是非常重要的概念，是组成界面的主要元素。而在iOS中，ViewController和View是组成一个界面的主要元素。在iOS中ViewContoller相当于是很多View的集合体，处理多个view。而React中的Component是一个更加集中的概念，无论是一个页面， 还是一个页面中的子元素，都是Component。</p><h4>Component</h4><h5>Component的生命周期</h5><p>借用其他人的图，能够清楚的看出Component的相对于iOS的ViewController来说，还是要复杂一些。</p><p><img src="/2018/07/19/2018-07-19/1.jpg" alt="Component的生命周期"></p><h5>Component的render</h5><p>对于Component来说，当一个组件render调用的时候， 它的子组件也会去调用render，如下图：</p><p>component2是component1的子组件，component1是component0的子组件，当component0的state有变化，会触发component0的render，这个时候， 就算component1和component2的render都会被调用起来。</p><p><img src="/2018/07/19/2018-07-19/2.png" alt="2.png"></p><p>其实对于component1和component2来说，他们的render没有必要调用起来，（即使后面渲染的时候，他们不会被重新渲染，但是还是会做额度的比较）。</p><h4>PureComponent</h4><p>相对于Component来说，PureComponent是一个新能更高的版本。PureComponent的优势在于能够<strong>减少触发不必要的render</strong>。</p><h5>PureComponent的生命周期</h5><p>PureComponent的生命周期和Component的生命周期是一致的。</p><h5>PureComponent的render</h5><p>总体来说，PureComponent和Component的区别在于，PureComponent通过重写 <code>shouldComponentUpdate</code> 函数，减少了render的调用。</p><p>当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (this._compositeType === CompositeTypes.PureClass) &#123;</span><br><span class="line">  shouldUpdate = !shallowEqual(prevProps, nextProps)</span><br><span class="line">  || !shallowEqual(inst.state, nextState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key 是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。</p><p>以上面的图举例：假设component0、component1和component2都是PureComponent，如果component0的state发生了改变，component0的render被触发了，然而component1和component2是不会触发render的。</p><h4>总结</h4><p>以上图示例，当component0的state或者props发生变化时，component1的state和props没有变化时，</p><p>render函数的调用次数：</p><table><thead><tr><th></th><th>Component</th><th>PureComponent</th></tr></thead><tbody><tr><td>component0</td><td>多次调用</td><td>多次调用</td></tr><tr><td>component1</td><td>多次调用</td><td>不会调用</td></tr><tr><td>component2</td><td>多次调用</td><td>不会调用</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;序&lt;/h3&gt;
&lt;p&gt;在客户端上，iOS和React的页面概念是不一样的。在React中，Component是非常重要的概念，是组成界面的主要元素。而在iOS中，ViewController和View是组成一个界面的主要元素。在iOS中ViewContoller相当于是很多
      
    
    </summary>
    
    
      <category term="React Native" scheme="http://wwhy.tech/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks 科学上网利器</title>
    <link href="http://wwhy.tech/2018/01/01/2018-01-01/"/>
    <id>http://wwhy.tech/2018/01/01/2018-01-01/</id>
    <published>2018-01-01T02:12:44.000Z</published>
    <updated>2018-04-09T10:25:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Shadowsocks：科学上网利器</p></blockquote><ul><li><a href="https://shadowsocks.org" target="_blank" rel="noopener">shadowsocks</a></li></ul><h2>安装</h2><p>Mac和Linux都默认有Python环境，直接使用Python的包管理器pip安装shadowsocks。</p><p>首先，下载pip的自动安装脚本<a href="https://bootstrap.pypa.io/get-pip.py" target="_blank" rel="noopener">bootstrap</a></p><ul><li>安装shadowsocks</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo python get-pip.py</span><br><span class="line">$ sudo pip install shadowsocks</span><br></pre></td></tr></table></figure></p><ul><li>新建添加配置文件 ss.config，可根据自定义的路径。配置账号进入<a href="#%E5%85%8D%E8%B4%B9ss%E8%B4%A6%E5%8F%B7">免费ss账号</a></li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>:<span class="string">"119.28.12.237"</span>,</span><br><span class="line">  <span class="attr">"server_port"</span>:<span class="number">51236</span>,</span><br><span class="line">  <span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">  <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">  <span class="attr">"password"</span>:<span class="string">"NdPaStaBLEyA"</span>,</span><br><span class="line">  <span class="attr">"timeout"</span>:<span class="number">60</span>,</span><br><span class="line">  <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">  <span class="attr">"workers"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>启动和关闭（ss.config在 root 目录下）</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudosslocal-c ss.config -dstart</span><br><span class="line">$ sudosslocal-c ss.config -dstop</span><br></pre></td></tr></table></figure></p><h2>使用</h2><h3>SwitchyOmega</h3><p>下载Chrome插件：<a href="https://github.com/FelisCatus/SwitchyOmega/releases" target="_blank" rel="noopener">SwitchyOmega.crx</a>，进行本地安装。</p><h4>配置Profile</h4><p>根据以上配置设置：</p><ul><li>Protocol: <strong>SOCKS5</strong></li><li>Server: <strong>127.0.0.1</strong></li><li>Port: <strong>1080</strong></li></ul><p><img src="/2018/01/01/2018-01-01/1.png" alt="Picture description"></p><h4>配置自动切换</h4><blockquote><p>根据规则自动切换使用代理，实现访问限制网站走代理，国内网站直连。</p></blockquote><ul><li>Rule List Format: <strong>AutoProxy</strong></li><li>Rule List Url: <strong>https://raw.githubusercontent.com/calfzhou/autoproxy-gfwlist/master/gfwlist.txt</strong></li></ul><p><img src="/2018/01/01/2018-01-01/2.png" alt="Picture description"></p><h4>使用SwitchyOmega</h4><p><img src="/2018/01/01/2018-01-01/3.png" alt="Picture description"></p><h2>免费ss账号</h2><ul><li><a href="https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B</a></li><li><a href="https://freessr.win/" target="_blank" rel="noopener">https://freessr.win/</a></li></ul><h2>参考</h2><ul><li>Shadowsocks: <a href="https://shadowsocks.org/" target="_blank" rel="noopener">https://shadowsocks.org/</a></li><li>Shadowsocks @Github: <a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks</a></li><li>SwitchyOmega @Webstore: <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif</a></li><li>SwitchyOmega @Github: <a href="https://github.com/FelisCatus/SwitchyOmega/releases" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega/releases</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Shadowsocks：科学上网利器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://shadowsocks.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shadowsocks&lt;/
      
    
    </summary>
    
    
      <category term="VPN" scheme="http://wwhy.tech/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>iOS 11 中 UIBarButtonItem 的变化</title>
    <link href="http://wwhy.tech/2017/11/09/2017-11-09/"/>
    <id>http://wwhy.tech/2017/11/09/2017-11-09/</id>
    <published>2017-11-09T11:31:50.000Z</published>
    <updated>2018-04-23T15:31:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3>序</h3><p>随着 iOS 11 和 Xcode 9 的发布，导航栏<code>UINavigationBar</code> 里面的控件 <code>UIBarButtonItem</code> 有一些变化，下面我们一起看看有哪些变化。</p><h3>变化</h3><ul><li><code>UIBarButtonItems</code> 的custom view的点击区域更小了</li><li>返回按钮的点击区域也更小了</li><li>如果上一个屏幕的 title 有变化，则返回按钮的 label 不再自动更新（iOS 10 前会自动更新）</li><li><code>UIBarButtonSystemItemFixedSpace</code> 类型的 <code>UIBarButtonItem</code> 现在至少有 8 个点的最小宽度，负数的 width 不再生效</li><li>重写 <code>alignmentRectInsets</code> 可能会导致 custom views 超出点击区域</li></ul><p>下面会详细的讲解上面几点变化。</p><h3>点击区域(Tap Areas)</h3><p>我们假设有一个 <strong>iOS 10</strong> 程序，其中包含两个有 custom view 的 <code>UIBarButtonItem</code>。然后我们使用 <code>Debug View Hierarchy</code> 去检查 custom 的真实大小。</p><p><img src="/2017/11/09/2017-11-09/1.png" alt="Picture description"></p><p>他们的点击区域实际上会更大，和下面的红色方块区域大小一致。</p><p><img src="/2017/11/09/2017-11-09/2.png" alt="Picture description"></p><p>然而在 <strong>iOS 11</strong> 上，显示的效果和上面的效果就不同了。点击区域大小和 custom view 的大小一致。</p><p><img src="/2017/11/09/2017-11-09/3.png" alt="Picture description"></p><p>在 <strong>iOS 11</strong> 上，这种点击区域的大小的确会使得用户很难点击。为了扩大点击区域，custom view 的需要扩大边距。我们可以创建一个拥有最小的size 约束的 Wrapper view。</p><p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrapperView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> minimumSize: <span class="type">CGSize</span> = <span class="type">CGSize</span>(width: <span class="number">44.0</span>, height: <span class="number">44.0</span>)</span><br><span class="line">    <span class="keyword">let</span> underlyingView: <span class="type">UIView</span></span><br><span class="line">    <span class="keyword">init</span>(underlyingView: <span class="type">UIView</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.underlyingView = underlyingView</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: underlyingView.bounds)</span><br><span class="line"></span><br><span class="line">        underlyingView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        addSubview(underlyingView)</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            underlyingView.leadingAnchor.constraint(equalTo: leadingAnchor),</span><br><span class="line">            underlyingView.trailingAnchor.constraint(equalTo: trailingAnchor),</span><br><span class="line">            underlyingView.topAnchor.constraint(equalTo: topAnchor),</span><br><span class="line">            underlyingView.bottomAnchor.constraint(equalTo: bottomAnchor),</span><br><span class="line">            heightAnchor.constraint(greaterThanOrEqualToConstant: minimumSize.height),</span><br><span class="line">            widthAnchor.constraint(greaterThanOrEqualToConstant: minimumSize.width)</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2017/11/09/2017-11-09/4.png" alt="Picture description"></p><h3>返回按钮(Back Button)</h3><h4>点击区域(Tap Area)</h4><p>当 view controller 的 title 很长的时候，iOS 11 上的返回按钮点击区域会变得更小。</p><p>在 iOS 10 上的返回按钮有一个比较大的最小宽度，利于用户点击。</p><p><img src="/2017/11/09/2017-11-09/5.png" alt="Picture description"></p><p>然而在 iOS 11 上，返回按钮的点击区域变得很小。更糟糕的是 view controller 的 title，有时看起来像是返回按钮的 label。</p><p><img src="/2017/11/09/2017-11-09/6.png" alt="Picture description"></p><h4>动态更新(Label)</h4><p>iOS 11 上面另外一个更新是返回按钮的 label。</p><p>举个例子，假设有一个能够自动更新 title 的 <code>First(4)</code> 页面 (UIViewController),</p><p><img src="/2017/11/09/2017-11-09/7.png" alt="Picture description"></p><p>界面从 <code>First(4)</code> 页面 push 到 <code>Second</code> 页面，</p><p><img src="/2017/11/09/2017-11-09/8.png" alt="Picture description"></p><p>在 iOS 10 上，当 <code>First(4)</code>的 title 从 First(4) 变化到 First(6) 之后，返回按钮也变成了 First(6)，</p><p><img src="/2017/11/09/2017-11-09/9.png" alt="Picture description"></p><p>而在 iOS 11 上，返回按钮的 label 并没有自动更新，而是保持不变。</p><p><img src="/2017/11/09/2017-11-09/10.png" alt="Picture description"></p><h3>自动布局(Auto Layout)</h3><p><code>UINavigationBar</code> 现在能够使用自动布局（Auto Layout）来布局它的 subviews（包括 custom views）。在今年的 WWDC上中的 <a href="https://developer.apple.com/videos/play/wwdc2017/204/" target="_blank" rel="noopener">Updating Your Apps for iOS 11</a> 里面有提到。</p><p>在 iOS 11 中，我们能够从 <code>Debug View Hierarchy</code> 检查 <code>UINavigationBar</code> 看到，<code>UINavigationBar</code> 内部的 buttons 都被放置在一个 stack view 中。</p><p><img src="/2017/11/09/2017-11-09/11.png" alt="Picture description"></p><p>当我们正确的实现了 custom view 的 <code>sizeThatFits</code> 和 <code>intrinsicContentSize</code>，<code>UINavigationBar</code>也会如以前那样工作正常。</p><p>但是，需要注意的是，当我们把custom view 的 <code>translatesAutoresizingMaskIntoConstraints</code> 设成 <code>false</code>，在 iOS 10（如果你的 App 还支持 iOS 10的话）上，可能出现一些莫名其妙的问题。比如可能导致custom view 的 top-left 方向布局错位。这种情况下，一个简单的保护代码如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let customView = createCustomView()</span><br><span class="line">if #available(iOS 11, *) &#123;</span><br><span class="line">    customView.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">&#125;</span><br><span class="line">navigationItem.rightBarButtonItem = UIBarButtonIte(customView: customView)</span><br></pre></td></tr></table></figure></p><h3>自定义对齐(Custom Alignment)</h3><p>很多时候，我们想能够自由的控制 custom <code>UIBarButtonItem</code> 的布局（对齐），特别是和屏幕两边的边距大小。在 iOS 10（及以前）来说，我们经常用到两种小技巧：</p><ul><li>使用fixed space item，即<code>UIBarButtonItem(barButtonSystemItem: .fixedSpace …)</code>，并且赋值一个负数，比如-15</li><li>重写 custom view 的 <code>alignmentRectInsets</code></li></ul><p>但是在 iOS 11 上，上面两个方法都有点变化，第一个办法已经失效，而第二个办法也有点问题。</p><h4>Fixed Space Items</h4><p>当我们使用 custom view 的时候， 默认的边距是16个点，</p><p><img src="/2017/11/09/2017-11-09/12.png" alt="Picture description"></p><p>假设我们想将边距减少到 8 个点，那么在 iOS 10 上面，我们需要设置fixed space <code>UIBarButtonItem</code> 的宽度为 -8 就可以达到我们想要的效果。</p><p><img src="/2017/11/09/2017-11-09/13.png" alt="Picture description"></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let spacer = UIBarButtonItem(barButtonSystemItem: .fixedSpace, target: nil, action: nil)</span><br><span class="line">spacer.width = -8</span><br><span class="line">let barButtonsItems = [</span><br><span class="line">    spacer,</span><br><span class="line">    UIBarButtonItem(customView: createCustomButton()),</span><br><span class="line">    UIBarButtonItem(customView: createCustomButton())</span><br><span class="line">]</span><br><span class="line">navigationItem.rightBarButtonItems = barButtonItems</span><br></pre></td></tr></table></figure></p><p><img src="/2017/11/09/2017-11-09/14.png" alt="Picture description"></p><p>然而在 iOS 11 上，修改fixed space <code>UIBarButtonItem</code> 的宽度为 -8 会不生效。</p><h4>Alignment Rect Insets</h4><p>而重写 custom view 的 <code>alignmentRectInsets</code>，在 iOS 10 上面也能够修改布局边距</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CustomView: UIView &#123;</span><br><span class="line">    var alignmentRectInsetsOverride: UIEdgeInsets?</span><br><span class="line">    override var alignmentRectInsets: UIEdgeInsets &#123;</span><br><span class="line">        return alignmentRectInsetsOverride ?? super.alignmentRectInsets</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设置 <code>alignmentRectInsets</code> 的值为 UIEdgeInsets(top: 0, left: -8, bottom: 0, right: 8)，也能够和前面的修改起到相同的作用</p><p><img src="/2017/11/09/2017-11-09/15.png" alt="Picture description"></p><p>上面的代码在 iOS 11 上面依然能够起到作用，但是有一个小的问题是，item 里面有一小部分超出了 stack view 的范围。超出的区域不能点击，也就意味着点击区域变小了。</p><p><img src="/2017/11/09/2017-11-09/16.png" alt="Picture description"></p><h4>Workaround</h4><p>根据前面<a href="#fixed-space-items">fixed space的例子</a>，我们发现相对于未使用 custom view 的情况，边距有所变小。</p><p><img src="/2017/11/09/2017-11-09/17.png" alt="Picture description"></p><p>当我们未使用 custom view 的时候，边距到屏幕边缘是 8 个点</p><p><img src="/2017/11/09/2017-11-09/18.png" alt="Picture description"></p><p>当我们使用了 custom view 的时候，边距到屏幕是 16 个点</p><p><img src="/2017/11/09/2017-11-09/19.png" alt="Picture description"></p><p>根据上面的发现，我们的目标是：让 custom view 的边距在 iOS 11 上面依然是 8 个点。添加一个 <code>fix space item</code> 将会使得内部的 stack view 减少边距，那么修改 <code>alignmentRectInsets</code> 的值去移动 <code>custom view</code> 的 frame，可以使内部的 stack view 对齐。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func alignedBarButtonItems() -&gt; [UIBarButtonItem] &#123;</span><br><span class="line">    let spacer = UIBarButtonItem(barButtonSystemItem: .fixedSpace, target: nil, action: nil)</span><br><span class="line">    spacer.width = 8</span><br><span class="line">    let barButtonsItems = [</span><br><span class="line">        spacer,</span><br><span class="line">        UIBarButtonItem(customView: createCustomButton(offset: spacer.width)),</span><br><span class="line">        UIBarButtonItem(customView: createCustomButton(offset: spacer.width)),</span><br><span class="line">        ]</span><br><span class="line">    return barButtonsItems</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createCustomButton(offset: CGFloat = 0) -&gt; UIButton &#123;</span><br><span class="line">    let button = CustomButton(frame: CGRect(x:0, y: 0, width: 24, height: 24))</span><br><span class="line">    button.alignmentRectInsetsOverride = UIEdgeInsets(top: 0, left: -offset, bottom: 0, right: offset)</span><br><span class="line">    button.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">    return button</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/2017/11/09/2017-11-09/20.png" alt="Picture description"></p><p>目前来说，这个 workaround 只能将边距设置为 8，如果我们将这个值设为一个更小的值，那么custom view 依然会超出 stack view。</p><h3>参考</h3><ul><li><a href="http://www.matrixprojects.net/p/uibarbuttonitem-ios11/" target="_blank" rel="noopener">UIBarButtonItem &amp; iOS 11</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;序&lt;/h3&gt;
&lt;p&gt;随着 iOS 11 和 Xcode 9 的发布，导航栏&lt;code&gt;UINavigationBar&lt;/code&gt; 里面的控件 &lt;code&gt;UIBarButtonItem&lt;/code&gt; 有一些变化，下面我们一起看看有哪些变化。&lt;/p&gt;
&lt;h3&gt;变化&lt;/h3
      
    
    </summary>
    
    
      <category term="iOS 11" scheme="http://wwhy.tech/tags/iOS-11/"/>
    
  </entry>
  
  <entry>
    <title>这些__attribute__的知识你应该知道</title>
    <link href="http://wwhy.tech/2017/10/03/2017-10-03/"/>
    <id>http://wwhy.tech/2017/10/03/2017-10-03/</id>
    <published>2017-10-03T15:01:48.000Z</published>
    <updated>2018-04-23T15:34:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3>序</h3><p>最近查看在网上发现了个有趣的小玩意<code>__attribute__</code>, 也就是 Clang Attributes，这是一个编译器提供的功能，能够让我向编译器指定一些特殊的功能，比如</p><ul><li><strong>attribute</strong>((deprecated))：描述一个方法已经废弃；</li><li><strong>attribute</strong>((objc_requires_super))：描述子类继承父类的方法时需要调用 super方法；</li><li><strong>attribute</strong>((cleanup(...))): 描述一个变量在作用域结束时能够执行指定方法；</li><li>......</li></ul><p>Clang 编译器提供了很多的 <code>__attribute__</code> 功能，下面会介绍一些 Objective-C 中常用的一些功能。</p><p>可以参考相关的文章 <a href="http://nshipster.com/__attribute__/" target="_blank" rel="noopener">NShipster</a> 和 <a href="http://blog.sunnyxx.com/2016/05/14/clang-attributes/" target="_blank" rel="noopener">clang-attributes</a>。</p><h3>__attribute__((deprecated))</h3><p>描述一个<strong>方法</strong>，表明这是一个被废弃的方法，如果有地方在调用，编译器会提示一个警告；并且也提供自定义警告信息，格式如下__attribute__((deprecated(&quot;meesage&quot;)))</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)thisIsADeprecatedMethod __attribute__((deprecated(&quot;This is a deprecated message&quot;)));</span><br></pre></td></tr></table></figure></p><p>在 Xcode 中，我们编写代码的时候， 编辑器会和 Clang 编译器的预编译系统配合，在我们写代码的时候，就在 IDE 中把警告给显示出来。</p><p><img src="/2017/10/03/2017-10-03/1.jpg" alt="Picture description"></p><h3>__attribute__((objc_boxable))</h3><p>能够给 struct 和 union 提供快捷的“包装”方式。</p><ol><li>CGRect， CGSize， CGPoint, CGVector 能够使用框架提供的 boxable 快速“包装”；</li><li>自定义 struct 或 union 类型，也可以添加 <strong>attribute</strong>((objc_boxable)) 以支持 boxable 快速“包装”。</li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CGPoint point = &#123;1, 2&#125;;                     // x = 1, y = 2</span><br><span class="line">CGRect rect1 = &#123;1, 2, 3, 4&#125;;                // x = 1, y = 2, width = 3, height = 4</span><br><span class="line">CGTriangle triange1 = &#123;1, 2, 3, 4, 5, 6&#125;;   // a.x = 1, a.y = 2, b.x = 3, b.y = 4, c.x = 5, c.y = 6</span><br><span class="line">// “包装”需要的数据不够，不够的数据补0</span><br><span class="line">CGSize size = &#123;1&#125;;                          // width = 1, height = 0</span><br><span class="line">// “包装”的 CGRect 中的 CGPoint 需要的数据不够，不够的数据补0</span><br><span class="line">CGRect rect2 = &#123;&#123;1&#125;, &#123;3, 4&#125;&#125;;               // x = 1, y = 0, width = 3, height = 4</span><br><span class="line"></span><br><span class="line">typedef struct __attribute__((objc_boxable)) &#123;</span><br><span class="line">    CGPoint x;</span><br><span class="line">    CGPoint y;</span><br><span class="line">    CGPoint z;</span><br><span class="line">&#125; CGTriangle;</span><br><span class="line"></span><br><span class="line">CGTriangle triange = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">// “包装”的数据多了，最后一条丢掉</span><br><span class="line">CGTriangle triange2 = &#123;1, 2, 3, 4, 5, 6, 7&#125;;// a.x = 1, a.y = 2, b.x = 3, b.y = 4, c.x = 5, c.y = 6</span><br></pre></td></tr></table></figure></p><p>这里“包装”的方式需要注意：</p><ul><li>可以采用<strong>平铺</strong>，如<code>{1, 2, 3, 4}</code>，也可以采用<strong>嵌套</strong>，如 <code>{ {1, 2}, {3, 4} }</code></li><li>如果“包装”赋值数据的个数比定义的少，则没有赋值的部分全部为0，如<code>CGSize size = {1}; // width = 1, height = 0</code></li><li>如果“包装”赋值数据的个数比定义的多，则多余的部分丢掉。如<code>CGTriangle triange2 = {1, 2, 3, 4, 5, 6, 7};// a.x = 1, a.y = 2, b.x = 3, b.y = 4, c.x = 5, c.y = 6</code></li></ul><p><img src="/2017/10/03/2017-10-03/2.jpg" alt="Picture description"></p><h3>__attribute__((objc_subclassing_restricted))</h3><p>描述一个<strong>类</strong>是一个不能被继承的类。</p><p>如果定义一个 Father 类，并且使用<code>__attribute__((objc_subclassing_restricted))</code>描述，那么如果一个 Son 类要去继承于 Father，编辑器会在编译器的预编译系统的帮助下，在 IDE 里面就把错误显示出来。</p><p><img src="/2017/10/03/2017-10-03/3.jpg" alt="Picture description"></p><h3>__attribute__((objc_requires_super))</h3><p>描述一个<strong>子类</strong>继承父类的方法时，需要调用 super，否则给出编译警告。</p><p>如果定义一个 Father 类，里面包含一个 call 方法，并且使用<code>__attribute__((objc_requires_super))</code>描述，那么如果一个 Son 在调用 call 的时候，需要显式的调用[super call]，如果没有调用，那么编辑器会在编译器的预编译系统的帮助下，在 IDE 里面就把警告显示出来。</p><p><img src="/2017/10/03/2017-10-03/4.jpg" alt="Picture description"></p><h3>__attribute__((warn_unused_result))</h3><p>描述一个<strong>方法</strong>，如果此方法有返回值，但是调用的地方<strong>并未使用返回值</strong>，编译器就会提示一个警告。（编辑器在编译器的预编译系统的帮助下，也会在 IDE 中显示警告）</p><p>如下面 Hippo 类的 bite 方法，使用了 <code>__attribute__((warn_unused_result))</code> 进行描述，在 bite 方法调用的时候没有使用返回值，编译器就就提示了一个警告</p><p><img src="/2017/10/03/2017-10-03/5.jpg" alt="Picture description"></p><h3>__attribute__((cleanup(...)))</h3><p>修饰一个<strong>变量</strong>，在它的作用域结束时可以执行一个指定的方法。</p><p>cleanup 是一个用好了就很爽的属性，详细内容可以查看<a href="http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/" target="_blank" rel="noopener">黑魔法__attribute__((cleanup))</a></p><h4>基本类型变量</h4><p>如果一个<strong>临时基本类型变量</strong>，在其超出作用域之后，这个变量会直接调用 cleanup。</p><p><img src="/2017/10/03/2017-10-03/8.jpg" alt="Picture description"></p><h4>对象变量</h4><p>如果一个<strong>临时变量对象</strong>，在超出其作用域之后，其临时变量（变量本身）会被释放，但是其指向的对象则会根据他的生命周期来决定是否释放。也就是说：</p><blockquote><ul><li>如果临时变量对象，没有被其他对象持有，那么最后其会先调用 cleanup，然后再调用 dealloc 方法</li><li>如果临时变量对象，被其他对象持有了，那么其只会调用 cleanup，而 dealloc 是不会被调用的。（这是因为临时变量（变量本身）会被释放，但是其指向的对象则会根据他的生命周期来决定是否释放）</li></ul></blockquote><p>下面两个例子可以很好的阐述上面两个观点：</p><p><img src="/2017/10/03/2017-10-03/6.jpg" alt="Picture description"></p><p>而下面的 hippo 对象被当前类给持有了，所以 dealloc 是不会调用的，只会调用 cleanup。</p><p><img src="/2017/10/03/2017-10-03/7.jpg" alt="Picture description"></p><h3>总结</h3><p>__attribute__ 提供了很多的编译时功能，恰当的运用这些功能，可以使我们的代码更加灵活。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;序&lt;/h3&gt;
&lt;p&gt;最近查看在网上发现了个有趣的小玩意&lt;code&gt;__attribute__&lt;/code&gt;, 也就是 Clang Attributes，这是一个编译器提供的功能，能够让我向编译器指定一些特殊的功能，比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;attri
      
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://wwhy.tech/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>NSTimer 不用的时候为什么需要调用invalidate？</title>
    <link href="http://wwhy.tech/2017/09/13/2017-09-13/"/>
    <id>http://wwhy.tech/2017/09/13/2017-09-13/</id>
    <published>2017-09-13T14:13:03.000Z</published>
    <updated>2018-04-19T03:05:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在调试 NSTimer，发现了一些有趣的东西，在此文分析研究一下。</p><h3>问题</h3><p>一个 viewController，持有了一个 timer, 当不需要这个 timer 的时候，能不能只调用 <code>self.timer = nil;</code>？</p><h3>什么是 NSTimer？</h3><p>根据 Apple 的开源代码 <a href="https://opensource.apple.com/source/CF/CF-1153.18/CFRunLoop.c" target="_blank" rel="noopener">CFRunLoop.c</a> 的定义，NSTimer 对应着一个 __CFRunLoopTimer 的结构体，具体代码如下：</p><h4>__CFRunLoopTimer</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopTimer &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    uint16_t _bits;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFMutableSetRef _rlModes;</span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    CFTimeInterval _interval;/* immutable */</span><br><span class="line">    CFTimeInterval _tolerance;          /* mutable */</span><br><span class="line">    uint64_t _fireTSR;/* TSR units */</span><br><span class="line">    CFIndex _order;/* immutable */</span><br><span class="line">    CFRunLoopTimerCallBack _callout;/* immutable */</span><br><span class="line">    CFRunLoopTimerContext _context;/* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>可以看到 __CFRunLoopTimer 里面有一个<code>CFRunLoopRef _runLoop</code>，这个表示 timer 是属于哪一个 runLoop 的，而里面的<code>CFMutableSetRef _rlModes</code>则表示这个 timer 是在 runLoop 的哪些 mode（__CFRunLoopMode） 中生效。</p><p>同时我们也能看到 __CFRunLoopTimer（即 NSTimer） 使用的是 pthread_mutex_t 锁。</p><h4>__CFRunLoopMode</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;/* must have the run loop locked before locking this */</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    char _padding[3];</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    dispatch_queue_t _queue;</span><br><span class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">    mach_port_t _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    void (*_msgPump)(void);</span><br><span class="line">#endif</span><br><span class="line">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class="line">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>从 __CFRunLoopMode 的源代码中， 我们可看到里面包含着一个<code>CFMutableArrayRef _timers</code>，也就是说 runLoopMode 有一个存放 timer 的数组，即当我们指定一个 timer 的 runLoopMode 的时候，<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]</code>， 会把这个 timer 放入相应的 runLoopMode 对象中。也就是说这个 runLoopMode 对象里面的 _timers 数组，会持有这个 timer 对象。这一点可以从 Xcode 的 Memory Graph中看到<img src="/2017/09/13/2017-09-13/1.jpg" alt="Picture description">当我们不需要一个 timer 的时候，我们是使用 NSTimer 的一个方法 <code>invalidate</code> 来进行解除所有和这个 timer 相关的持有关系。</p><p>同样我们也能看到 __CFRunLoopMode 使用的也是 pthread_mutex_t 锁。</p><h4>回答前面的问题</h4><p><strong>当我有一个 viewController，持有了一个 timer, 我能不能只调用 <code>self.timer = nil;</code>?</strong></p><blockquote><p>不能，因为 <code>self.timer = nil;</code> 只是解除了 viewController 持有 timer，但是并没有解除 runLoopMode 里面的数组持有 timer 的关系，所以必须调用invalidate来解除所有和 timer 相关的关系。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在调试 NSTimer，发现了一些有趣的东西，在此文分析研究一下。&lt;/p&gt;
&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;一个 viewController，持有了一个 timer, 当不需要这个 timer 的时候，能不能只调用 &lt;code&gt;self.timer = nil;&lt;/co
      
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://wwhy.tech/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>面向对象：三大特征、五大原则</title>
    <link href="http://wwhy.tech/2017/08/21/2017-08-21/"/>
    <id>http://wwhy.tech/2017/08/21/2017-08-21/</id>
    <published>2017-08-21T12:31:01.000Z</published>
    <updated>2018-08-05T12:42:21.967Z</updated>
    
    <content type="html"><![CDATA[<h3>三大特征</h3><h4>封装</h4><blockquote><p>将对象的属性和细节隐藏起来，只提供公共的访问方式。</p></blockquote><h4>继承</h4><blockquote><p>继承是从已有的类派生出新的类，新的类能继承已有类的数据属性和行为，并扩展新的功能。</p></blockquote><h4>多态</h4><blockquote><p>同一个实现接口，使用不同的实例而执行不同的操作。</p></blockquote><h3>五大原则</h3><h4>单一职责原则</h4><blockquote><p>一个类只负责一项职责。</p></blockquote><h4>开放-封闭原则</h4><blockquote><p>对扩展开放，对修改关闭。</p></blockquote><h4>依赖倒置原则</h4><blockquote><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p></blockquote><h4>里氏替换原则</h4><blockquote><p>只要父类能出现的地方子类也可以出现，而且替换为子类不会产生任何错误或异常，但是反过来就不行，有子类出现的地方，父类未必就能适应。。</p></blockquote><h4>接口隔离原则</h4><blockquote><p>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;三大特征&lt;/h3&gt;
&lt;h4&gt;封装&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;将对象的属性和细节隐藏起来，只提供公共的访问方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;继承&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;继承是从已有的类派生出新的类，新的类能继承已有类的数
      
    
    </summary>
    
    
      <category term="软件开发，面向对象" scheme="http://wwhy.tech/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Category的加载机制</title>
    <link href="http://wwhy.tech/2017/07/07/2017-07-07/"/>
    <id>http://wwhy.tech/2017/07/07/2017-07-07/</id>
    <published>2017-07-07T15:19:00.000Z</published>
    <updated>2018-08-06T07:00:37.293Z</updated>
    
    <content type="html"><![CDATA[<h3>序</h3><p>一直在使用Category，但是对Category的机制不太了解，这里对Category的机制进行一个总结。</p><p>参考：<a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">传送门</a></p><h4>总结</h4><ol><li>Category是在程序启动时作用的， 并且是在 +load 方法调用前</li><li>加载顺序是：先类，后Category</li><li>Category是运行时决议，Swift 的 Extension 是编译时决议</li><li>Category是 runtime 在程序启动时，进行作用<ul><li>加载实例方法到class的函数列表中</li><li>加载类方法到 meta class 的函数列表中</li></ul></li><li>Category增加方法，会更新 class 和 meta class 的函数列表，Category新增的方法在前， 原函数列表在后；</li><li>Category如果新增了一个同名的方法，其实并没有替换到原来的函数，只是新增的同名方法在函数列表的前面，原来的方法在后面，所以有时会给人一个错觉——覆盖了方法</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;序&lt;/h3&gt;
&lt;p&gt;一直在使用Category，但是对Category的机制不太了解，这里对Category的机制进行一个总结。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://tech.meituan.com/DiveIntoCategory.html&quot; targ
      
    
    </summary>
    
    
      <category term="Category" scheme="http://wwhy.tech/tags/Category/"/>
    
  </entry>
  
  <entry>
    <title>atomic是不是线程安全的？</title>
    <link href="http://wwhy.tech/2017/05/27/2017-05-17/"/>
    <id>http://wwhy.tech/2017/05/27/2017-05-17/</id>
    <published>2017-05-27T08:21:00.000Z</published>
    <updated>2018-08-05T12:45:21.790Z</updated>
    
    <content type="html"><![CDATA[<h3>序</h3><p>记得以前面试的时候，有面试官问到atomic安全不安全，今天突然想起了这个问题，再总结记录一下。</p><h4>结论</h4><p>atomic是线程不安全的。</p><p>atomic只是保证了getter和setter存取方法的线程安全，但并不能保证这个属性所对应的成员变量是线程安全的。</p><h4>解释</h4><p>意思就是： 如果多个线程调用了getter或者setter，那么这些getter和setter的调用时线性的， 保证了同一时间只有一个函数(setter和getter)在调用， 但是并不能避免这个属性所对应的成员变量是线程安全的。</p><p>例如：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic) NSString * name;</span><br></pre></td></tr></table></figure></p><p>系统自动生成的getter:</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(NSString *)name;</span><br></pre></td></tr></table></figure></p><p>Setter:</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)setName:(NSString *)name;</span><br></pre></td></tr></table></figure></p><p>假设name所对应的成员变量是<code>_name</code>。</p><p>atomic保证的是，setter和getter是线程安全的。如，线程1调用getter了，线程2调用了setter，线程3调用了setter，那么atomic保证了一个线程的调用顺序：getter-&gt;setter-&gt;setter.</p><p>但是atomic并不能保证成员变量_name的线程安全。例如上面的例子中， 如果有个线程4直接release了_name， 那么在线程1、线程2或者线程3的调用过程中， 直接造成崩溃。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;序&lt;/h3&gt;
&lt;p&gt;记得以前面试的时候，有面试官问到atomic安全不安全，今天突然想起了这个问题，再总结记录一下。&lt;/p&gt;
&lt;h4&gt;结论&lt;/h4&gt;
&lt;p&gt;atomic是线程不安全的。&lt;/p&gt;
&lt;p&gt;atomic只是保证了getter和setter存取方法的线程安全，但并
      
    
    </summary>
    
    
      <category term="atomic" scheme="http://wwhy.tech/tags/atomic/"/>
    
  </entry>
  
  <entry>
    <title>再总结一下NSString 与 NSMutableString 的 property 约束</title>
    <link href="http://wwhy.tech/2017/04/02/2017-04-02/"/>
    <id>http://wwhy.tech/2017/04/02/2017-04-02/</id>
    <published>2017-04-02T09:43:00.000Z</published>
    <updated>2018-04-06T12:04:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在网上看了很多关于 NSString 的 property 约束，不过总感觉总结得没那么直接。这里我再重复的总结一下。</p><h3>对于 NSString 来说，到底用 copy 还是 strong?</h3><p>看看下面的代码：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface Test: NSObject</span><br><span class="line">@property (nonatomic, strong) NSString * string;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Some Code here …………</span><br><span class="line"></span><br><span class="line">NSMutableString * aStr = [@&quot;hello&quot; mutableCopy];</span><br><span class="line">Test * test = [Test new];</span><br><span class="line">test.string = aStr;</span><br><span class="line">[aStr appendString:@&quot; world&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;, test.string);</span><br></pre></td></tr></table></figure></p><p>以上代码，原本打算 test 对象的 string 对象赋值之后就不会改变，即一直都是 hello，然而上面的代码输出是 hello world，违背了代码设计的初衷。</p><p>NSString 如果使用 strong 的话， 从外部给这个属性赋值，可能是一个 NSMutableString，如果外部把这个 NSMutableString 的值给改变了， 那么这个属性的值也会被改变。</p><h3>对于NSMutableString来说，用 copy 还是 strong?</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface Test: NSObject</span><br><span class="line">@property (nonatomic, copy) NSMutableString * mString;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Some Code here …………</span><br><span class="line"></span><br><span class="line">NSMutableString * aStr = [@&quot;hello&quot; mutableCopy];</span><br><span class="line">Test * test = [Test new];</span><br><span class="line">test.mString = aStr;</span><br><span class="line">[test.mString appendString:@&quot;world&quot;];</span><br></pre></td></tr></table></figure></p><p>以上代码中，test 对象的 mString 属性，由于定义的 copy，然而<code>copy属性会拷贝一个不可变的值</code>，然而我们对它进行一些可变协议的操作，即执行：[NSString appendString:]，程序崩溃。</p><p>NSMutableString 如果使用 copy 的话，将一个外部对象赋值给这个属性的时候， 会进行一次 copy 操作， 然而 copy 是拷贝出一个不可变的对象给属性（实际上应该调用 mutableCopy，但是@property 并没有 mutableCopy），如果之后对这个属性（实际上是一个不可变的对象）进行可变协议的调用， 那么程序就会崩溃。</p><h4>总结</h4><p>和 NSString 与 NSMutableString 类似，NSArray 与 NSMutableArray， NSDictionary 与 NSMutableDictiontary也与以上运行效果一致。</p><ul><li><strong>NSString, NSArray 与 NSDictionary 使用 copy；</strong></li><li><strong>NSMutableString, NSMutableArray 与 NSMutableDictionary使用 strong。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在网上看了很多关于 NSString 的 property 约束，不过总感觉总结得没那么直接。这里我再重复的总结一下。&lt;/p&gt;
&lt;h3&gt;对于 NSString 来说，到底用 copy 还是 strong?&lt;/h3&gt;
&lt;p&gt;看看下面的代码：&lt;/p&gt;
&lt;p&gt;&lt;figure 
      
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://wwhy.tech/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>优化之离屏渲染</title>
    <link href="http://wwhy.tech/2017/03/20/2017-03-20/"/>
    <id>http://wwhy.tech/2017/03/20/2017-03-20/</id>
    <published>2017-03-20T15:59:12.000Z</published>
    <updated>2018-04-13T15:33:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是总结一下我对离屏渲染的理解，之前一直不太理解离屏渲染到底是个什么，也不太理解为什么他会引起滚动界面卡顿，一直也没有去深入了解，自己也深感惭愧。以前看到了<a href="https://blog.ibireme.com" target="_blank" rel="noopener">@ibireme</a>写的<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a>这篇文章，里面也描述了下屏幕显示原理。现在再次深入阅读，才比较理解离屏渲染到底是怎么回事。</p><h3>屏幕显示原理</h3><p>引用一下<a href="https://blog.ibireme.com" target="_blank" rel="noopener">@ibireme</a>的原文</p><blockquote><p>首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。</p></blockquote><blockquote><p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p></blockquote><p><img src="/2017/03/20/2017-03-20/ios_screen_scan.png" alt=""></p><blockquote><p>在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p></blockquote><p>这里介绍了 GPU 为了效率问题，使用了两个帧缓冲区。对于帧缓冲区的个数，iOS 系统中使用的是双缓冲机制，而 Android 使用的三缓冲机制。题外话，不得不佩服 iOS 系统的设计，在硬件不如 Android 的提前下，界面的流畅度却超过 Android 机器。</p><h3>离屏渲染</h3><p>直接引用网络上的一段文字：</p><blockquote><p>OpenGL中，GPU屏幕渲染有以下两种方式：</p><ol><li><strong>On-Screen Rendering</strong> 意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</li><li><strong>Off-Screen Rendering</strong> 意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</li></ol></blockquote><p>对于一个 UIView 的渲染过程：</p><blockquote><ol><li>UIView的layer层有一个content，指向一块缓存，即backing store</li><li>UIView绘制时，会调用drawRect方法，通过context将数据写入backing store</li><li>在backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上</li></ol></blockquote><p><img src="/2017/03/20/2017-03-20/uiview_render.png" alt=""></p><p>当我们在使用<strong>Group Opacity</strong>、<strong>corner（圆角）</strong>、<strong>shadow（阴影）</strong>、<strong>edge antialiasing（抗锯齿）<strong>和</strong>mask</strong>等视图功能的时候，由于图层不是那种简单的覆盖，而是需要额外计算图层的显示关系，由于当前已经是 GPU 渲染了，所以在 GPU 的当前屏幕缓冲区外，新建了一个缓冲区，在这个缓冲区中，去进行这些额外的渲染，这就是离屏渲染。</p><ol><li>创建离屏缓冲区是一个代价是很大的。</li><li>（假设我们的在界面中画了圆角），如果我们创建的圆角 N 个，那么在这个离屏缓冲区中，去处理这 N 个圆角的时候，会大量的切换上下文，然而，切换上下文也是一个代价非常大的操作。</li></ol><p>所以，当在开发过程中，<strong>如果离屏渲染没有处理好，对 App 的性能影响是非常大的</strong>， 后文会有相关的实例对比。</p><h3>离屏渲染的优化</h3><ul><li>尽量使用当前屏幕渲染。由于离屏渲染、CPU渲染可能带来的性能问题，一般情况下，尽量使用当前屏幕渲染。</li><li>由于 GPU 的浮点运算能力比 CPU 强，虽然 CPU 渲染的效率不如 GPU，但有时使用 CPU 渲染的效率会比 GPU 离屏渲染好，毕竟离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。</li></ul><h4>圆角</h4><p>一般情况，我们写圆角的时候，会这样写：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.layer.cornerRadius = 10;</span><br><span class="line">view.layer.masksToBounds = YES;</span><br></pre></td></tr></table></figure></p><p>运行时，查看 Off-screen Rendered</p><p><img src="/2017/03/20/2017-03-20/corner_offscreen_rendered.jpg" alt="corner_offscreen_rendered"></p><p>我们可以看到按钮上的四个角被黄色覆盖，表明这四个角被离屏渲染了，这是因为 GPU 渲染的时候，发现这个按钮不是一个规整的图形，不能简单的采用(x, y, width, height)的规则进行渲染，对于上面的四个角，必须进行离屏渲染，新建一块缓冲区进行计算渲染，和下一层的 layer 进行合成处理，这样才能再界面上形成一个有弧度的视觉效果。</p><p>然而这里只有四个角所处的矩形范围进行了离屏渲染，是因为计算机里面的图形坐标都是以类似于(x, y, width, height)的规则来描述的，也就是说是一个矩形图形。然而这儿不是整个按钮而只是其他的四个角的区域的原因，是因为效率问题，GPU 确定除了四个角所在的矩形区域之外， 其他的区域都不需要合成处理，这样选择性的进行离屏渲染，能够获得更高的性能。</p><p>这里我们如何处理圆角带来的离屏渲染呢？答案是采用 Core Graphics 提供的函数，在 CPU 里面绘制圆角，这样相当于在 CPU 处理的时候就已经 GPU 离屏渲染做的事情给完成了。</p><p>使用下面提供的代码能够给 UIView 的子类添加圆角，能够避免离屏渲染。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 仅添加圆角</span><br><span class="line">[view addCorner:30];</span><br><span class="line">// 添加圆角和边框</span><br><span class="line">[view addCorner:30 borderWidth:0.5 borderColor:[UIColor redColor]];</span><br></pre></td></tr></table></figure></p><p>由于<code>addCorner:</code>和<code>addCorner:borderWidth:borderColor:</code>的代码较长，需要查看和下载的，<a href="https://snippets.cacher.io/snippet/6450c5ef0cf37484bb58" target="_blank" rel="noopener">请点击此处查看下载</a></p><h4>阴影</h4><p>对于 shadow 来说，</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shadowColor = [UIColor redColor].CGColor;</span><br><span class="line">view.layer.shadowOffset = CGSizeMake(5, 5);</span><br><span class="line">view.layer.shadowOpacity = 1.0;</span><br></pre></td></tr></table></figure></p><p>查看 Off-screen Rendered</p><p><img src="/2017/03/20/2017-03-20/shadow_offscreen_rendered.jpg" alt="corner_offscreen_rendered"></p><p>可以看到，整个 view 的 frame，包括 frame 之外还有一点都进行了离屏渲染。</p><p>这儿有一个问题，如果有谁知道，请在评论区讲解一下。<strong>为什么是整个 view 都被离屏渲染了呢？</strong> 为了效率中间的区域可以不需要被离屏渲染，但是对于 shadow 却被离屏渲染了？</p><p>对于 shadow 的优化，直接在上面的代码后面添加一句就行了</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shadowColor = [UIColor redColor].CGColor;</span><br><span class="line">view.layer.shadowOffset = CGSizeMake(5, 5);</span><br><span class="line">view.layer.shadowOpacity = 1.0;</span><br><span class="line">// 添加 shadowPath，能够解决离屏渲染</span><br><span class="line">view.layer.shadowPath = [UIBezierPath bezierPathWithRect:view.bounds].CGPath;</span><br></pre></td></tr></table></figure></p><h4>Mask</h4><p>一般的 Mask 设置代码如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIImageView * mask = [[UIImageView alloc] initWithFrame:view.bounds];</span><br><span class="line">mask.image = [UIImage imageNamed:@&quot;mask.png&quot;];</span><br><span class="line">view.maskView = mask;</span><br></pre></td></tr></table></figure></p><p>对于 Mask 的优化，其实并没有一个很好的方式来解决，目前的解决方案是：rasterize（光栅化），然而 rasterize（光栅化）也会造成离屏渲染，不过由于离屏渲染大部分时候会在大量出现的时候造成性能问题，所以在滚动页面进行 rasterize（光栅化）的时候，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用, 把GPU的操作转到CPU上了，生成位图缓存，各种阴影遮罩等效果也会保存到位图中并缓存起来，直接读取复用，从而减少渲染的频度。rasterize（光栅化）有一个不好的效果，会造成文字 label 视觉效果模糊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章主要是总结一下我对离屏渲染的理解，之前一直不太理解离屏渲染到底是个什么，也不太理解为什么他会引起滚动界面卡顿，一直也没有去深入了解，自己也深感惭愧。以前看到了&lt;a href=&quot;https://blog.ibireme.com&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
      <category term="iOS 优化" scheme="http://wwhy.tech/tags/iOS-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS的单元测试</title>
    <link href="http://wwhy.tech/2016/11/22/2016-11-22/"/>
    <id>http://wwhy.tech/2016/11/22/2016-11-22/</id>
    <published>2016-11-22T03:54:10.000Z</published>
    <updated>2018-07-24T12:05:22.767Z</updated>
    
    <content type="html"><![CDATA[<h3>序</h3><p>Specta + OCMock + Expecta + OHHTTPStubs + FBSnapshotTestCase + &quot;Expecta+Snapshots&quot;</p><p>Specta: BDD框架 <a href="https://github.com/specta/specta" target="_blank" rel="noopener">参考链接</a></p><p>Expecta: 断言框架 <a href="https://github.com/specta/expecta" target="_blank" rel="noopener">参考链接</a></p><p>OCMock: mock框架 <a href="http://ocmock.org" target="_blank" rel="noopener">参考链接</a></p><p>FBSnapshotTestCase: 截图测试框架 <a href="https://github.com/facebookarchive/ios-snapshot-test-case" target="_blank" rel="noopener">参考链接</a></p><p>Expecta+Snapshots: FBSnapshotTestCase的扩展， 支持Expecta <a href="https://github.com/dblock/ios-snapshot-test-case-expecta" target="_blank" rel="noopener">参考链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;序&lt;/h3&gt;
&lt;p&gt;Specta + OCMock + Expecta + OHHTTPStubs + FBSnapshotTestCase + &amp;quot;Expecta+Snapshots&amp;quot;&lt;/p&gt;
&lt;p&gt;Specta: BDD框架 &lt;a href=&quot;htt
      
    
    </summary>
    
    
      <category term="单元测试" scheme="http://wwhy.tech/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的闭包定义</title>
    <link href="http://wwhy.tech/2016/08/21/2016-08-21/"/>
    <id>http://wwhy.tech/2016/08/21/2016-08-21/</id>
    <published>2016-08-21T04:30:11.000Z</published>
    <updated>2018-02-28T12:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4>定义闭包变量</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var closureName: (ParameterTypes) -&gt; (ReturnType)</span><br></pre></td></tr></table></figure></p><h4>定义可选闭包变量</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var closureName: ((ParameterTypes) -&gt; (ReturnType))?</span><br></pre></td></tr></table></figure></p><h4>定义闭包别名</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typealias ClosureType = (ParameterTypes) -&gt; (ReturnType)</span><br></pre></td></tr></table></figure></p><h4>定义闭包常量</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let closureName: ClosureType = &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><h4>在函数内部</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funcName(&#123;(ParameterTypes) -&gt; (ReturnType) in statements&#125;)</span><br></pre></td></tr></table></figure></p><h4>作为函数参数</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort(&#123; (item1: Int, item2: Int) -&gt; Bool in return item1 &lt; item2 &#125;)</span><br></pre></td></tr></table></figure></p><h4>作为函数参数(隐式参数类型)</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort(&#123; (item1, item2) -&gt; Bool in return item1 &lt; item2 &#125;)</span><br></pre></td></tr></table></figure></p><h4>作为函数参数(隐式参数类型、隐式返回类型)</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort(&#123; (item1, item2) in return item1 &lt; item2 &#125;)</span><br></pre></td></tr></table></figure></p><h4>作为函数最后的参数</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort &#123; (item1, item2) in return item1 &lt; item2 &#125;</span><br></pre></td></tr></table></figure></p><h4>作为函数最后的参数(使用简略参数命名方式)</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort &#123; return $0 &lt; $1 &#125;</span><br></pre></td></tr></table></figure></p><h4>作为函数最后的参数(隐式返回值)</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort &#123; $0 &lt; $1 &#125;</span><br></pre></td></tr></table></figure></p><h4>作为函数最后的参数(as a reference to an existing function)</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort(&lt;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4&gt;定义闭包变量&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
      
    
    </summary>
    
    
      <category term="Swift" scheme="http://wwhy.tech/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的init</title>
    <link href="http://wwhy.tech/2016/07/07/2016-07-07/"/>
    <id>http://wwhy.tech/2016/07/07/2016-07-07/</id>
    <published>2016-07-07T08:02:10.000Z</published>
    <updated>2018-04-24T09:04:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3>前言</h3><p>最近总算开始做新项目， 语言肯定的选Swift了。问题一个接一个，不过还好，来一个解决一个。今天遇到了Swift中的init的问题， 用Xcode也没有自动补全，也没有看到相关init的东西，所以对init构造过程进行一个分析。</p><h3>两个类</h3><p>有一个Parent的Class</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Parent: NSObject &#123;</span><br><span class="line">override init() &#123;</span><br><span class="line">NSLog(&quot;Parent Init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一个Child的Class继承于Parent</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Child: Parent &#123;</span><br><span class="line">override init() &#123;</span><br><span class="line">NSLog(&quot;Child Init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>调用代码</h3><p>在其他的某个类中，初始化一个Child对象出来，</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func doSomething() &#123;</span><br><span class="line">Child()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于Xcode没有默认添加super.init()，所以这里到底是怎样一个逻辑过程？按照我对其他语言的理解，我猜测是有两种可能情况：</p><ol><li>只会输出Child Init</li><li>先输出Parent Init，然后输出Child Init&quot;</li></ol><h3>运行代码</h3><p>代码的运行情况出乎我的意料</p><p>输出结果是：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child Init</span><br><span class="line">Parent Init</span><br></pre></td></tr></table></figure></p><p>居然先输出Child Init。</p><p>也就是说先调用了子类的init(), 然后再调用父类的init()。</p><h3>结论</h3><p>Swift中的init过程，子类如果没有调用super.init()，那么会在子类的init()的<strong>末尾</strong>隐式添加super.init()</p><h3>我们该如何处理？</h3><p>一般情况，我们需要在子类的init()中，应该显式地、尽快地调用super.init()</p><p>如上面的Child类就该写成</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Child: Parent &#123;</span><br><span class="line">override init() &#123;</span><br><span class="line">super.init() // 显式的添加super.init()到第一行</span><br><span class="line">NSLog(&quot;Child Init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;最近总算开始做新项目， 语言肯定的选Swift了。问题一个接一个，不过还好，来一个解决一个。
今天遇到了Swift中的init的问题， 用Xcode也没有自动补全，也没有看到相关init的东西，所以对init构造过程进行一个分析。&lt;/p&gt;
&lt;h3&gt;两
      
    
    </summary>
    
    
      <category term="Swift" scheme="http://wwhy.tech/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>也来写一写我理解中的代码布局、xib布局以及storyboard布局</title>
    <link href="http://wwhy.tech/2016/06/08/2016-06-08/"/>
    <id>http://wwhy.tech/2016/06/08/2016-06-08/</id>
    <published>2016-06-07T16:02:10.000Z</published>
    <updated>2018-04-24T09:06:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3>前言</h3><p>前几天在CocoaChina上看了一篇关于代码布局、xib布局以及storyboard布局的争论，我也参与了其中，大半夜的写出了我自己的理解，结果一个误操作，打了十几分钟的字，就被自己丢失掉了（哎，再一次上了没有保存的当！）。不过本着要发表点自己意见的心态， 还是再次花了十几分钟，重新发表了自己的想法。自己总算参与了iOS开发大军的互喷中。</p><h3>为什么有人不喜欢xib和storyboard？</h3><p>看了网上很多人的评论，我总结了下，90%的开发认为：</p><ol><li>xib和storyboard布局，没有代码布局看着方便，在xib和storyboard上看UI布局的比较费时；</li><li>xib和storyboard布局，容易冲突，多人协作的时候容易抓狂；</li><li>xib和storyboard布局，不方便维护，后期需求修改的时候没有代码布局修改方便；</li></ol><p>其他的一些观点，我就不列举了。</p><p>有位朋友这样说</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于支持xib的，我只想说，别坑自己人。</span><br><span class="line">团队开发矛盾就在这时候体现出来了。</span><br><span class="line">以后去了插件化公司你就会明白为什么不让你用xib了。</span><br><span class="line">之前公司所有分配的项目都要求打包成静态库或者动态库，而且不允许打包bundle，统一使用主框架下的图片。</span><br><span class="line">我看看你们傻眼不？</span><br></pre></td></tr></table></figure></p><p>对于这位朋友的观点，我的想法是类似于架构设计，要有远见，但是也不能过度设计。因地制宜，杀鸡不用牛刀。</p><h3>我自己的一些观点</h3><p>就个人观点， storyboard，xib 和代码， 都有各自适合的场景。</p><p>在我的理解中， UI 是分成<strong>UI 逻辑</strong>和<strong>UI 布局</strong>， 然而， sb 和 xib，以及代码， 都只是 UI 布局这个环节。</p><p>我个人倾向于 sb， 为什么呢？</p><ol><li>sb 更加直观， 对于整个项目来说， 一个完美的流程图及时呈现在你面前， 你肯定对 整个项目的掌握了然于胸。</li><li>sb 实现起来更快。不论是添加控件，还是给控件布局，sb 都会很 nice 的。</li><li>sb 减少了开发的工作。（我说的只是减少， 不是完全没了）sb 能够很好的把布局工作从代码中拿出来， 让我们的代码只专注于我们的业务和逻辑。我的开发理念是， 能少写一行代码的就不能多写一行。能把事情交给 apple 做的， 我就不会自己来做。</li></ol><p>和代码布局相比起来，</p><ol><li>代码布局不直观， 流程得看代码。（不要说整个项目都是一个人从头到尾做的，自己很清楚之类的。这儿主要讨论团队开发）</li><li>代码布局太费时了。用代码布局， 首先要写添加这个控件的代码， 然后写这个控件的布局，或者写约束，相对 sb 来说，的确太耗时了。不过可能大家要说 sb 修改起来太麻烦了。 其实就我个人观点，sb 相对于代码来说，修改起来反而更加简单。因为要修改或者删除 sb 里面的控件的时候， 如果理不清的时候， 直接删掉所有控件， 重新添加控件， 重现布局，也不是一个多大的事。然而， 如果用代码的话， 大家首先得理解这段代码的含义， 然后还要考虑这个代码能不能改， 能不能删，思考的时间绝对不少了。 而且，一般大家也不敢随便动其他人写的代码， 怕改出问题。</li><li>代码布局效率高，sb 效率低。我觉得编译时期， 的确 sb布局被代码完爆。 不过在运行的时候， 个人觉得差不太多， 估计代码布局会好点。但是相对于程序结构来说， 我觉得完全没必要。</li><li>代码布局相对于 sb 布局的团队合作来说， 要略胜一筹。但是 sb 布局的冲突， 其实从技术上是可以规避的， 不过具体方式就不在这儿讨论了</li></ol><p>在 UI 的实现上，我在概念上将 UI分成 UI 逻辑和 UI 布局， 我觉得苹果之所以出 xib 和 sb，就是想把 UI 布局的工作给抽出来，让我们只关注与业务和逻辑。不要被布局给困扰。</p><p>所以我在实现UI 的时候， 基本上我的代码只看得到 UI 逻辑部分， 而布局相关的代码完全没了。</p><h3>一些大牛的观点</h3><p>https://onevcat.com/2013/12/code-vs-xib-vs-storyboard/</p><p>http://blog.devtang.com/2015/03/22/ios-dev-controversy-2/</p><h3>写在最后</h3><p>虽然上面我说了我个人倾向于sb，不过还是得看项目，不同的项目要因地制宜。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;前几天在CocoaChina上看了一篇关于代码布局、xib布局以及storyboard布局的争论，我也参与了其中，大半夜的写出了我自己的理解，结果一个误操作，打了十几分钟的字，就被自己丢失掉了（哎，再一次上了没有保存的当！）。不过本着要发表点自己意见
      
    
    </summary>
    
    
      <category term="UI布局" scheme="http://wwhy.tech/tags/UI%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>细说 iOS 中的 http 协议</title>
    <link href="http://wwhy.tech/2016/02/02/2016-02-02/"/>
    <id>http://wwhy.tech/2016/02/02/2016-02-02/</id>
    <published>2016-02-02T08:21:09.000Z</published>
    <updated>2018-08-05T12:46:56.840Z</updated>
    
    <content type="html"><![CDATA[<h3>前言</h3><p>http 协议在我们的工作中，基本上99%的 app 都是无法避免的，http 协议的重要性，不亚于 UIKit 的存在。</p><p>当我们在工作中，对 http 协议的理解层度，很多时候决定了我们项目架构的深度和稳定性；当我们在<strong>找工作</strong>中，对 http 协议的理解层度，很多时候也决定了我们应聘的职位 level。</p><p>在这篇文章中，我会详细的、系统的讲解下 http 协议，以及 http 协议在 iOS 中相关的一些知识。</p><blockquote><ul><li>http 协议细说</li><li>http 协议在 iOS 中如何存在的</li></ul></blockquote><h3>http 协议</h3><p>关于 http 协议，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;http 协议在我们的工作中，基本上99%的 app 都是无法避免的，http 协议的重要性，不亚于 UIKit 的存在。&lt;/p&gt;
&lt;p&gt;当我们在工作中，对 http 协议的理解层度，很多时候决定了我们项目架构的深度和稳定性；
当我们在&lt;strong
      
    
    </summary>
    
    
      <category term="Http" scheme="http://wwhy.tech/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>C++ 字符串比较 汇编代码实现</title>
    <link href="http://wwhy.tech/2011/01/15/2011-01-15/"/>
    <id>http://wwhy.tech/2011/01/15/2011-01-15/</id>
    <published>2011-01-15T08:21:49.000Z</published>
    <updated>2018-02-28T12:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3>前言</h3><p>导入很久很久以前写的一篇技术！缅怀下以前写 C++ 的日子</p><h3>正文</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int asmCmp(char* str1, char*str2)&#123;</span><br><span class="line">    _asm&#123;</span><br><span class="line">        mov eax, str1</span><br><span class="line">            mov ebx, str2</span><br><span class="line">s1:</span><br><span class="line">        mov cl, [ebx]</span><br><span class="line">        cmp [eax], cl</span><br><span class="line">            jne ret2</span><br><span class="line">            cmp cl, 0</span><br><span class="line">            je ret1</span><br><span class="line">            add eax, 1</span><br><span class="line">            add ebx, 1</span><br><span class="line">            jmp s1</span><br><span class="line">ret1:</span><br><span class="line">        mov eax, 0</span><br><span class="line">            jmp end1;</span><br><span class="line">ret2:</span><br><span class="line">        mov eax, 1//这里可能不同的编译器需要不同的代码</span><br><span class="line">end1:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;导入很久很久以前写的一篇技术！缅怀下以前写 C++ 的日子&lt;/p&gt;
&lt;h3&gt;正文&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="C++和汇编" scheme="http://wwhy.tech/tags/C-%E5%92%8C%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C++ 字符串拷贝 汇编代码实现</title>
    <link href="http://wwhy.tech/2011/01/15/2011-01-16/"/>
    <id>http://wwhy.tech/2011/01/15/2011-01-16/</id>
    <published>2011-01-15T08:20:38.000Z</published>
    <updated>2018-02-28T12:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3>前言</h3><p>导入很久很久以前写的一篇技术！缅怀下以前写 C++ 的日子</p><h3>正文</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void asmCpy(char* str1, char* str2)</span><br><span class="line">&#123;</span><br><span class="line">    _asm&#123;</span><br><span class="line">        mov eax, str1//将str1的地址赋值给eax</span><br><span class="line">        mov ecx, str2//将str2的地址赋值给ecx</span><br><span class="line">s1:</span><br><span class="line">        mov bl, [eax]//去eax地址所指向的值，赋值给bl</span><br><span class="line">        cmp [eax], 0//比较当前这个字符是不是NULL</span><br><span class="line">        je end1//如果是NULL，就是字符串结束了，跳转到end1</span><br><span class="line">//如果不是，则继续下面的代码</span><br><span class="line">        mov [ecx], bl//将bl里面的值赋值给ecx所指向的内存</span><br><span class="line">        add eax, 1// eax的地址值增加1</span><br><span class="line">        add ecx, 1// ecx的地址值增加1</span><br><span class="line">        jmp s1// 跳到前面的循环</span><br><span class="line">end1:</span><br><span class="line">        mov [ecx], 0//给最后一个字符设置成NULL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;导入很久很久以前写的一篇技术！缅怀下以前写 C++ 的日子&lt;/p&gt;
&lt;h3&gt;正文&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="C++和汇编" scheme="http://wwhy.tech/tags/C-%E5%92%8C%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C++前向声明隐含的问题</title>
    <link href="http://wwhy.tech/2010/09/29/2010-09-29/"/>
    <id>http://wwhy.tech/2010/09/29/2010-09-29/</id>
    <published>2010-09-29T15:17:57.000Z</published>
    <updated>2018-02-28T12:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3>前言</h3><p>导入很久很久以前写的一篇技术！缅怀下以前写 C++ 的日子</p><h3>正文</h3><p>今天写代码的时候，遇到了一个很神奇的问题，在代码编译的时候很正常，编译成功。但是运行的时候，问题就出来了。</p><p>B *b;</p><p>我在代码中A *a = b-&gt;constructA();（constructA()在内部调用new，创建一个新的A的实例）即由类B的对象b生成一个类A的对象a，这里没有问题，我在这里什么都不做，直接调用delete a；神奇的时刻到来了，程序直接崩溃。</p><p>经过几个小时的分析是因为include和前向声明的问题。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.h:</span><br><span class="line">class A&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B.h:</span><br><span class="line">class A;//这里前向声明A，</span><br><span class="line">class B&#123;</span><br><span class="line">    A * constrctA()&#123;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main.cpp:</span><br><span class="line">#include &quot;B.h&quot;</span><br><span class="line">int main()&#123;</span><br><span class="line">    B *b = new B;</span><br><span class="line">    A *a = b-&gt;constructA();</span><br><span class="line">    delete a;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在编译的时候，很成功，因为在B.h中，编译器找得到A这个类声明或者是定义的语句：class A;因此在编译的时候，没有#include “A.h”也能够正常编译！！！问题就出在这儿了。</p><p>在运行的时候，A *a = b-&gt;constructA();没问题然后这儿的A并没有实现，他并没有任何函数，当我调用delete a；的时候，会自动调用析构函数，这样根本就找不到析构函数，</p><p>所以，程序在运行delete a；的时候会crash。</p><p>解决的办法就是添加#include &quot;A.h&quot;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;导入很久很久以前写的一篇技术！缅怀下以前写 C++ 的日子&lt;/p&gt;
&lt;h3&gt;正文&lt;/h3&gt;
&lt;p&gt;今天写代码的时候，遇到了一个很神奇的问题，在代码编译的时候很正常，编译成功。
但是运行的时候，问题就出来了。&lt;/p&gt;
&lt;p&gt;B *b;&lt;/p&gt;
&lt;p&gt;我
      
    
    </summary>
    
    
      <category term="C++和汇编" scheme="http://wwhy.tech/tags/C-%E5%92%8C%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
</feed>
