<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>成都老刘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-06T12:04:41.269Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Gang Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>再总结一下NSString 与 NSMutableString 的 property 约束</title>
    <link href="http://yoursite.com/2017/04/02/2017-04-02/"/>
    <id>http://yoursite.com/2017/04/02/2017-04-02/</id>
    <published>2017-04-02T09:43:00.000Z</published>
    <updated>2018-04-06T12:04:41.269Z</updated>
    
    <content type="html"><![CDATA[<p>之前在网上看了很多关于 NSString 的 property 约束，不过总感觉总结得没那么直接。这里我再重复的总结一下。</p><h3>对于 NSString 来说，到底用 copy 还是 strong?</h3><p>看看下面的代码：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface Test: NSObject</span><br><span class="line">@property (nonatomic, strong) NSString * string;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Some Code here …………</span><br><span class="line"></span><br><span class="line">NSMutableString * aStr = [@&quot;hello&quot; mutableCopy];</span><br><span class="line">Test * test = [Test new];</span><br><span class="line">test.string = aStr;</span><br><span class="line">[aStr appendString:@&quot; world&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;, test.string);</span><br></pre></td></tr></table></figure></p><p>以上代码，原本打算 test 对象的 string 对象赋值之后就不会改变，即一直都是 hello，然而上面的代码输出是 hello world，违背了代码设计的初衷。</p><p>NSString 如果使用 strong 的话， 从外部给这个属性赋值，可能是一个 NSMutableString，如果外部把这个 NSMutableString 的值给改变了， 那么这个属性的值也会被改变。</p><h3>对于NSMutableString来说，用 copy 还是 strong?</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface Test: NSObject</span><br><span class="line">@property (nonatomic, copy) NSMutableString * mString;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Some Code here …………</span><br><span class="line"></span><br><span class="line">NSMutableString * aStr = [@&quot;hello&quot; mutableCopy];</span><br><span class="line">Test * test = [Test new];</span><br><span class="line">test.mString = aStr;</span><br><span class="line">[test.mString appendString:@&quot;world&quot;];</span><br></pre></td></tr></table></figure></p><p>以上代码中，test 对象的 mString 属性，由于定义的 copy，然而<code>copy属性会拷贝一个不可变的值</code>，然而我们对它进行一些可变协议的操作，即执行：[NSString appendString:]，程序崩溃。</p><p>NSMutableString 如果使用 copy 的话，将一个外部对象赋值给这个属性的时候， 会进行一次 copy 操作， 然而 copy 是拷贝出一个不可变的对象给属性（实际上应该调用 mutableCopy，但是@property 并没有 mutableCopy），如果之后对这个属性（实际上是一个不可变的对象）进行可变协议的调用， 那么程序就会崩溃。</p><h4>总结</h4><p>和 NSString 与 NSMutableString 类似，NSArray 与 NSMutableArray， NSDictionary 与 NSMutableDictiontary也与以上运行效果一致。</p><ul><li><strong>NSString, NSArray 与 NSDictionary 使用 copy；</strong></li><li><strong>NSMutableString, NSMutableArray 与 NSMutableDictionary使用 strong。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在网上看了很多关于 NSString 的 property 约束，不过总感觉总结得没那么直接。这里我再重复的总结一下。&lt;/p&gt;
&lt;h3&gt;对于 NSString 来说，到底用 copy 还是 strong?&lt;/h3&gt;
&lt;p&gt;看看下面的代码：&lt;/p&gt;
&lt;p&gt;&lt;figure 
      
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://yoursite.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>优化之离屏渲染</title>
    <link href="http://yoursite.com/2017/03/20/2017-03-20/"/>
    <id>http://yoursite.com/2017/03/20/2017-03-20/</id>
    <published>2017-03-20T15:59:12.000Z</published>
    <updated>2018-04-06T16:31:55.109Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是总结一下我对离屏渲染的理解，之前一直不太理解离屏渲染到底是个什么，也不太理解为什么他会引起滚动界面卡顿，一直也没有去深入了解，自己也深感惭愧。以前看到了<a href="https://blog.ibireme.com" target="_blank" rel="noopener">@ibireme</a>写的<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a>这篇文章，里面也描述了下屏幕显示原理。现在再次深入阅读，才比较理解离屏渲染到底是怎么回事。</p><h3>屏幕显示原理</h3><p>引用一下<a href="https://blog.ibireme.com" target="_blank" rel="noopener">@ibireme</a>的原文</p><blockquote><p>首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。</p></blockquote><blockquote><p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p></blockquote><p><img src="/2017/03/20/2017-03-20/ios_screen_scan.png" alt=""></p><blockquote><p>在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p></blockquote><p>这里介绍了 GPU 为了效率问题，使用了两个帧缓冲区。对于帧缓冲区的个数，iOS 系统中使用的是双缓冲机制，而 Android 使用的三缓冲机制。题外话，不得不佩服 iOS 系统的设计，在硬件不如 Android 的提前下，界面的流畅度却超过 Android 机器。</p><h3>离屏渲染</h3><p>直接引用网络上的一段文字：</p><blockquote><p>OpenGL中，GPU屏幕渲染有以下两种方式：</p></blockquote><blockquote><p>1.<strong>On-Screen Rendering</strong>&lt;br&gt;意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。&lt;br&gt;2.<strong>Off-Screen Rendering</strong>&lt;br&gt;意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p></blockquote><p>对于一个 UIView 的渲染过程：</p><blockquote><ol><li>UIView的layer层有一个content，指向一块缓存，即backing store</li><li>UIView绘制时，会调用drawRect方法，通过context将数据写入backing store</li><li>在backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上</li></ol></blockquote><p><img src="/2017/03/20/2017-03-20/uiview_render.png" alt=""></p><p>当我们在使用<strong>Group Opacity</strong>、<strong>corner（圆角）</strong>、<strong>shadow（阴影）</strong>、<strong>edge antialiasing（抗锯齿）<strong>和</strong>mask</strong>等视图功能的时候，由于图层不是那种简单的覆盖，而是需要额外计算图层的显示关系，由于当前已经是 GPU 渲染了，所以在 GPU 的当前屏幕缓冲区外，新建了一个缓冲区，在这个缓冲区中，去进行这些额外的渲染，这就是离屏渲染。</p><ol><li>创建离屏缓冲区是一个代价是很大的。</li><li>（假设我们的在界面中画了圆角），如果我们创建的圆角 N 个，那么在这个离屏缓冲区中，去处理这 N 个圆角的时候，会大量的切换上下文，然而，切换上下文也是一个代价非常大的操作。</li></ol><p>所以，当在开发过程中，<strong>如果离屏渲染没有处理好，对 App 的性能影响是非常大的</strong>， 后文会有相关的实例对比。</p><h3>离屏渲染的优化</h3><ul><li>尽量使用当前屏幕渲染。由于离屏渲染、CPU渲染可能带来的性能问题，一般情况下，尽量使用当前屏幕渲染。</li><li>由于 GPU 的浮点运算能力比 CPU 强，虽然 CPU 渲染的效率不如 GPU，但有时使用 CPU 渲染的效率会比 GPU 离屏渲染好，毕竟离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。</li></ul><h4>圆角</h4><p>一般情况，我们写圆角的时候，会这样写：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.layer.cornerRadius = 10;</span><br><span class="line">view.layer.masksToBounds = YES;</span><br></pre></td></tr></table></figure></p><p>运行时，查看 Off-screen Rendered</p><p><img src="/2017/03/20/2017-03-20/corner_offscreen_rendered.jpg" alt="corner_offscreen_rendered"></p><p>我们可以看到按钮上的四个角被黄色覆盖，表明这四个角被离屏渲染了，这是因为 GPU 渲染的时候，发现这个按钮不是一个规整的图形，不能简单的采用(x, y, width, height)的规则进行渲染，对于上面的四个角，必须进行离屏渲染，新建一块缓冲区进行计算渲染，和下一层的 layer 进行合成处理，这样才能再界面上形成一个有弧度的视觉效果。</p><p>然而这里只有四个角所处的矩形范围进行了离屏渲染，是因为计算机里面的图形坐标都是以类似于(x, y, width, height)的规则来描述的，也就是说是一个矩形图形。然而这儿不是整个按钮而只是其他的四个角的区域的原因，是因为效率问题，GPU 确定除了四个角所在的矩形区域之外， 其他的区域都不需要合成处理，这样选择性的进行离屏渲染，能够获得更高的性能。</p><p>这里我们如何处理圆角带来的离屏渲染呢？答案是采用 Core Graphics 提供的函数，在 CPU 里面绘制圆角，这样相当于在 CPU 处理的时候就已经 GPU 离屏渲染做的事情给完成了。</p><p>使用下面提供的代码能够给 UIView 的子类添加圆角，能够避免离屏渲染。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 仅添加圆角</span><br><span class="line">[view addCorner:30];</span><br><span class="line">// 添加圆角和边框</span><br><span class="line">[view addCorner:30 borderWidth:0.5 borderColor:[UIColor redColor]];</span><br></pre></td></tr></table></figure></p><p>由于<code>addCorner:</code>和<code>addCorner:borderWidth:borderColor:</code>的代码较长，需要查看和下载的，<a href="https://blog.ibireme.com" target="_blank" rel="noopener">请点击此处查看下载</a></p><h4>阴影</h4><p>对于 shadow 来说，</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shadowColor = [UIColor redColor].CGColor;</span><br><span class="line">view.layer.shadowOffset = CGSizeMake(5, 5);</span><br><span class="line">view.layer.shadowOpacity = 1.0;</span><br></pre></td></tr></table></figure></p><p>查看 Off-screen Rendered</p><p><img src="/2017/03/20/2017-03-20/shadow_offscreen_rendered.jpg" alt="corner_offscreen_rendered"></p><p>可以看到，整个 view 的 frame，包括 frame 之外还有一点都进行了离屏渲染。</p><p>这儿有一个问题，如果有谁知道，请在评论区讲解一下。<strong>为什么是整个 view 都被离屏渲染了呢？</strong> 为了效率中间的区域可以不需要被离屏渲染，但是对于 shadow 却被离屏渲染了？</p><p>对于 shadow 的优化，直接在上面的代码后面添加一句就行了</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shadowColor = [UIColor redColor].CGColor;</span><br><span class="line">view.layer.shadowOffset = CGSizeMake(5, 5);</span><br><span class="line">view.layer.shadowOpacity = 1.0;</span><br><span class="line">// 添加 shadowPath，能够解决离屏渲染</span><br><span class="line">view.layer.shadowPath = [UIBezierPath bezierPathWithRect:view.bounds].CGPath;</span><br></pre></td></tr></table></figure></p><h4>Mask</h4><p>一般的 Mask 设置代码如下：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIImageView * mask = [[UIImageView alloc] initWithFrame:view.bounds];</span><br><span class="line">mask.image = [UIImage imageNamed:@&quot;mask.png&quot;];</span><br><span class="line">view.maskView = mask;</span><br></pre></td></tr></table></figure></p><p>对于 Mask 的优化，其实并没有一个很好的方式来解决，目前的解决方案是：rasterize（光栅化），然而 rasterize（光栅化）也会造成离屏渲染，不过由于离屏渲染大部分时候会在大量出现的时候造成性能问题，所以在滚动页面进行 rasterize（光栅化）的时候，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用, 把GPU的操作转到CPU上了，生成位图缓存，各种阴影遮罩等效果也会保存到位图中并缓存起来，直接读取复用，从而减少渲染的频度。rasterize（光栅化）有一个不好的效果，会造成文字 label 视觉效果模糊。</p><h4>附件代码</h4><p><img src="/2017/03/20/2017-03-20/123.gz" alt="123"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章主要是总结一下我对离屏渲染的理解，之前一直不太理解离屏渲染到底是个什么，也不太理解为什么他会引起滚动界面卡顿，一直也没有去深入了解，自己也深感惭愧。以前看到了&lt;a href=&quot;https://blog.ibireme.com&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
      <category term="iOS 优化" scheme="http://yoursite.com/tags/iOS-%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的闭包定义</title>
    <link href="http://yoursite.com/2016/08/21/2016-08-21/"/>
    <id>http://yoursite.com/2016/08/21/2016-08-21/</id>
    <published>2016-08-21T04:30:11.000Z</published>
    <updated>2018-02-28T12:20:28.314Z</updated>
    
    <content type="html"><![CDATA[<h4>定义闭包变量</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var closureName: (ParameterTypes) -&gt; (ReturnType)</span><br></pre></td></tr></table></figure></p><h4>定义可选闭包变量</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var closureName: ((ParameterTypes) -&gt; (ReturnType))?</span><br></pre></td></tr></table></figure></p><h4>定义闭包别名</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typealias ClosureType = (ParameterTypes) -&gt; (ReturnType)</span><br></pre></td></tr></table></figure></p><h4>定义闭包常量</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let closureName: ClosureType = &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><h4>在函数内部</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funcName(&#123;(ParameterTypes) -&gt; (ReturnType) in statements&#125;)</span><br></pre></td></tr></table></figure></p><h4>作为函数参数</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort(&#123; (item1: Int, item2: Int) -&gt; Bool in return item1 &lt; item2 &#125;)</span><br></pre></td></tr></table></figure></p><h4>作为函数参数(隐式参数类型)</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort(&#123; (item1, item2) -&gt; Bool in return item1 &lt; item2 &#125;)</span><br></pre></td></tr></table></figure></p><h4>作为函数参数(隐式参数类型、隐式返回类型)</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort(&#123; (item1, item2) in return item1 &lt; item2 &#125;)</span><br></pre></td></tr></table></figure></p><h4>作为函数最后的参数</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort &#123; (item1, item2) in return item1 &lt; item2 &#125;</span><br></pre></td></tr></table></figure></p><h4>作为函数最后的参数(使用简略参数命名方式)</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort &#123; return $0 &lt; $1 &#125;</span><br></pre></td></tr></table></figure></p><h4>作为函数最后的参数(隐式返回值)</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort &#123; $0 &lt; $1 &#125;</span><br></pre></td></tr></table></figure></p><h4>作为函数最后的参数(as a reference to an existing function)</h4><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort(&lt;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4&gt;定义闭包变量&lt;/h4&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
      
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的init</title>
    <link href="http://yoursite.com/2016/07/07/2016-07-07/"/>
    <id>http://yoursite.com/2016/07/07/2016-07-07/</id>
    <published>2016-07-07T08:02:10.000Z</published>
    <updated>2018-02-28T12:20:28.314Z</updated>
    
    <content type="html"><![CDATA[<h3>前言</h3><p>最近总算开始做新项目， 语言肯定的选Swift了。问题一个接一个，不过还好，来一个解决一个。今天遇到了Swift中的init的问题， 用Xcode也没有自动补全，也没有看到相关init的东西，所以对init构造过程进行一个分析。</p><h3>两个类</h3><p>有一个Parent的Class</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Parent: NSObject &#123;</span><br><span class="line">override init() &#123;</span><br><span class="line">NSLog(&quot;Parent Init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一个Child的Class继承于Parent</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Child: Parent &#123;</span><br><span class="line">override init() &#123;</span><br><span class="line">NSLog(&quot;Child Init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>调用代码</h3><p>在其他的某个类中，初始化一个Child对象出来，</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func doSomething() &#123;</span><br><span class="line">Child()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于Xcode没有默认添加super.init()，所以这里到底是怎样一个逻辑过程？按照我对其他语言的理解，我猜测是有两种可能情况：</p><ol><li>只会输出Child Init</li><li>先输出Parent Init，然后输出Child Init&quot;</li></ol><h3>运行代码</h3><p>代码的运行情况出乎我的意料</p><p>输出结果是：</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child Init</span><br><span class="line">Parent Init</span><br></pre></td></tr></table></figure></p><p>居然先输出Child Init。</p><p>也就是说先调用了子类的init(), 然后再调用父类的init()。</p><h3>结论</h3><p>&lt;b&gt;Swift中的init过程，子类如果没有调用super.init()，那么会&lt;font color=blue&gt;在子类的init()的&lt;font color=red&gt;末尾&lt;/font&gt;隐式添加super.init()&lt;/font&gt;&lt;/b&gt;</p><h3>我们该如何处理？</h3><p>&lt;b&gt;一般情况，我们需要在子类的init()中，应该显式地、尽快地调用super.init()&lt;/b&gt;</p><p>如上面的Child类就该写成</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Child: Parent &#123;</span><br><span class="line">override init() &#123;</span><br><span class="line">super.init() // 显式的添加super.init()到第一行</span><br><span class="line">NSLog(&quot;Child Init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;最近总算开始做新项目， 语言肯定的选Swift了。问题一个接一个，不过还好，来一个解决一个。
今天遇到了Swift中的init的问题， 用Xcode也没有自动补全，也没有看到相关init的东西，所以对init构造过程进行一个分析。&lt;/p&gt;
&lt;h3&gt;两
      
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>也来写一写我理解中的代码布局、xib布局以及storyboard布局</title>
    <link href="http://yoursite.com/2016/06/08/2016-06-08/"/>
    <id>http://yoursite.com/2016/06/08/2016-06-08/</id>
    <published>2016-06-07T16:02:10.000Z</published>
    <updated>2018-02-28T12:20:28.314Z</updated>
    
    <content type="html"><![CDATA[<h3>前言</h3><p>前几天在CocoaChina上看了一篇关于代码布局、xib布局以及storyboard布局的争论，我也参与了其中，大半夜的写出了我自己的理解，结果一个误操作，打了十几分钟的字，就被自己丢失掉了（哎，再一次上了没有保存的当！）。不过本着要发表点自己意见的心态， 还是再次花了十几分钟，重新发表了自己的想法。自己总算参与了iOS开发大军的互喷中。</p><h3>为什么有人不喜欢xib和storyboard？</h3><p>看了网上很多人的评论，我总结了下，90%的开发认为：</p><ol><li>xib和storyboard布局，没有代码布局看着方便，在xib和storyboard上看UI布局的比较费时；</li><li>xib和storyboard布局，容易冲突，多人协作的时候容易抓狂；</li><li>xib和storyboard布局，不方便维护，后期需求修改的时候没有代码布局修改方便；</li></ol><p>其他的一些观点，我就不列举了。</p><p>有位朋友这样说</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于支持xib的，我只想说，别坑自己人。</span><br><span class="line">团队开发矛盾就在这时候体现出来了。</span><br><span class="line">以后去了插件化公司你就会明白为什么不让你用xib了。</span><br><span class="line">之前公司所有分配的项目都要求打包成静态库或者动态库，而且不允许打包bundle，统一使用主框架下的图片。</span><br><span class="line">我看看你们傻眼不？</span><br></pre></td></tr></table></figure></p><p>对于这位朋友的观点，我的想法是类似于架构设计，要有远见，但是也不能过度设计。因地制宜，杀鸡不用牛刀。</p><h3>我自己的一些观点</h3><p>就个人观点， storyboard，xib 和代码， 都有各自适合的场景。</p><p>在我的理解中， UI 是分成 &lt;font color=red&gt;UI逻辑&lt;/font&gt;和&lt;font color=red&gt;UI 布局&lt;/font&gt;， 然而， sb 和 xib，以及代码， 都只是 UI 布局这个环节。</p><p>我个人倾向于 sb， 为什么呢？</p><ol><li>sb 更加直观， 对于整个项目来说， 一个完美的流程图及时呈现在你面前， 你肯定对 整个项目的掌握了然于胸。</li><li>sb 实现起来更快。不论是添加控件，还是给控件布局，sb 都会很 nice 的。</li><li>sb 减少了开发的工作。（我说的只是减少， 不是完全没了）sb 能够很好的把布局工作从代码中拿出来， 让我们的代码只专注于我们的业务和逻辑。我的开发理念是， 能少写一行代码的就不能多写一行。能把事情交给 apple 做的， 我就不会自己来做。</li></ol><p>和代码布局相比起来，</p><ol><li>代码布局不直观， 流程得看代码。（不要说整个项目都是一个人从头到尾做的，自己很清楚之类的。这儿主要讨论团队开发）</li><li>代码布局太费时了。用代码布局， 首先要写添加这个控件的代码， 然后写这个控件的布局，或者写约束，相对 sb 来说，的确太耗时了。不过可能大家要说 sb 修改起来太麻烦了。 其实就我个人观点，sb 相对于代码来说，修改起来反而更加简单。因为要修改或者删除 sb 里面的控件的时候， 如果理不清的时候， 直接删掉所有控件， 重新添加控件， 重现布局，也不是一个多大的事。然而， 如果用代码的话， 大家首先得理解这段代码的含义， 然后还要考虑这个代码能不能改， 能不能删，思考的时间绝对不少了。 而且，一般大家也不敢随便动其他人写的代码， 怕改出问题。</li><li>代码布局效率高，sb 效率低。我觉得编译时期， 的确 sb布局被代码完爆。 不过在运行的时候， 个人觉得差不太多， 估计代码布局会好点。但是相对于程序结构来说， 我觉得完全没必要。</li><li>代码布局相对于 sb 布局的团队合作来说， 要略胜一筹。但是 sb 布局的冲突， 其实从技术上是可以规避的， 不过具体方式就不在这儿讨论了</li></ol><p>在 UI 的实现上，我在概念上将 UI分成 UI 逻辑和 UI 布局， 我觉得苹果之所以出 xib 和 sb，就是想把 UI 布局的工作给抽出来，让我们只关注与业务和逻辑。不要被布局给困扰。</p><p>所以我在实现UI 的时候， 基本上我的代码只看得到 UI 逻辑部分， 而布局相关的代码完全没了。</p><h3>一些大牛的观点</h3><p>https://onevcat.com/2013/12/code-vs-xib-vs-storyboard/</p><p>http://blog.devtang.com/2015/03/22/ios-dev-controversy-2/</p><h3>写在最后</h3><p>虽然上面我说了我个人倾向于sb，不过还是得看项目，不同的项目要因地制宜。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;前几天在CocoaChina上看了一篇关于代码布局、xib布局以及storyboard布局的争论，我也参与了其中，大半夜的写出了我自己的理解，结果一个误操作，打了十几分钟的字，就被自己丢失掉了（哎，再一次上了没有保存的当！）。不过本着要发表点自己意见
      
    
    </summary>
    
    
      <category term="UI布局" scheme="http://yoursite.com/tags/UI%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>C++ 字符串比较 汇编代码实现</title>
    <link href="http://yoursite.com/2011/01/15/2011-01-15/"/>
    <id>http://yoursite.com/2011/01/15/2011-01-15/</id>
    <published>2011-01-15T08:21:49.000Z</published>
    <updated>2018-02-28T12:20:28.314Z</updated>
    
    <content type="html"><![CDATA[<h3>前言</h3><p>导入很久很久以前写的一篇技术！缅怀下以前写 C++ 的日子</p><h3>正文</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int asmCmp(char* str1, char*str2)&#123;</span><br><span class="line">    _asm&#123;</span><br><span class="line">        mov eax, str1</span><br><span class="line">            mov ebx, str2</span><br><span class="line">s1:</span><br><span class="line">        mov cl, [ebx]</span><br><span class="line">        cmp [eax], cl</span><br><span class="line">            jne ret2</span><br><span class="line">            cmp cl, 0</span><br><span class="line">            je ret1</span><br><span class="line">            add eax, 1</span><br><span class="line">            add ebx, 1</span><br><span class="line">            jmp s1</span><br><span class="line">ret1:</span><br><span class="line">        mov eax, 0</span><br><span class="line">            jmp end1;</span><br><span class="line">ret2:</span><br><span class="line">        mov eax, 1//这里可能不同的编译器需要不同的代码</span><br><span class="line">end1:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;导入很久很久以前写的一篇技术！缅怀下以前写 C++ 的日子&lt;/p&gt;
&lt;h3&gt;正文&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="C++和汇编" scheme="http://yoursite.com/tags/C-%E5%92%8C%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C++ 字符串拷贝 汇编代码实现</title>
    <link href="http://yoursite.com/2011/01/15/2011-01-16/"/>
    <id>http://yoursite.com/2011/01/15/2011-01-16/</id>
    <published>2011-01-15T08:20:38.000Z</published>
    <updated>2018-02-28T12:20:28.313Z</updated>
    
    <content type="html"><![CDATA[<h3>前言</h3><p>导入很久很久以前写的一篇技术！缅怀下以前写 C++ 的日子</p><h3>正文</h3><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void asmCpy(char* str1, char* str2)</span><br><span class="line">&#123;</span><br><span class="line">    _asm&#123;</span><br><span class="line">        mov eax, str1//将str1的地址赋值给eax</span><br><span class="line">        mov ecx, str2//将str2的地址赋值给ecx</span><br><span class="line">s1:</span><br><span class="line">        mov bl, [eax]//去eax地址所指向的值，赋值给bl</span><br><span class="line">        cmp [eax], 0//比较当前这个字符是不是NULL</span><br><span class="line">        je end1//如果是NULL，就是字符串结束了，跳转到end1</span><br><span class="line">//如果不是，则继续下面的代码</span><br><span class="line">        mov [ecx], bl//将bl里面的值赋值给ecx所指向的内存</span><br><span class="line">        add eax, 1// eax的地址值增加1</span><br><span class="line">        add ecx, 1// ecx的地址值增加1</span><br><span class="line">        jmp s1// 跳到前面的循环</span><br><span class="line">end1:</span><br><span class="line">        mov [ecx], 0//给最后一个字符设置成NULL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;导入很久很久以前写的一篇技术！缅怀下以前写 C++ 的日子&lt;/p&gt;
&lt;h3&gt;正文&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="C++和汇编" scheme="http://yoursite.com/tags/C-%E5%92%8C%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C++前向声明隐含的问题</title>
    <link href="http://yoursite.com/2010/09/29/2010-09-29/"/>
    <id>http://yoursite.com/2010/09/29/2010-09-29/</id>
    <published>2010-09-29T15:17:57.000Z</published>
    <updated>2018-02-28T12:20:28.313Z</updated>
    
    <content type="html"><![CDATA[<h3>前言</h3><p>导入很久很久以前写的一篇技术！缅怀下以前写 C++ 的日子</p><h3>正文</h3><p>今天写代码的时候，遇到了一个很神奇的问题，在代码编译的时候很正常，编译成功。但是运行的时候，问题就出来了。</p><p>B *b;</p><p>我在代码中A *a = b-&gt;constructA();（constructA()在内部调用new，创建一个新的A的实例）即由类B的对象b生成一个类A的对象a，这里没有问题，我在这里什么都不做，直接调用delete a；神奇的时刻到来了，程序直接崩溃。</p><p>经过几个小时的分析是因为include和前向声明的问题。</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.h:</span><br><span class="line">class A&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B.h:</span><br><span class="line">class A;//这里前向声明A，</span><br><span class="line">class B&#123;</span><br><span class="line">    A * constrctA()&#123;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main.cpp:</span><br><span class="line">#include &quot;B.h&quot;</span><br><span class="line">int main()&#123;</span><br><span class="line">    B *b = new B;</span><br><span class="line">    A *a = b-&gt;constructA();</span><br><span class="line">    delete a;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在编译的时候，很成功，因为在B.h中，编译器找得到A这个类声明或者是定义的语句：class A;因此在编译的时候，没有#include “A.h”也能够正常编译！！！问题就出在这儿了。</p><p>在运行的时候，A *a = b-&gt;constructA();没问题然后这儿的A并没有实现，他并没有任何函数，当我调用delete a；的时候，会自动调用析构函数，这样根本就找不到析构函数，</p><p>所以，程序在运行delete a；的时候会crash。</p><p>解决的办法就是添加#include &quot;A.h&quot;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;导入很久很久以前写的一篇技术！缅怀下以前写 C++ 的日子&lt;/p&gt;
&lt;h3&gt;正文&lt;/h3&gt;
&lt;p&gt;今天写代码的时候，遇到了一个很神奇的问题，在代码编译的时候很正常，编译成功。
但是运行的时候，问题就出来了。&lt;/p&gt;
&lt;p&gt;B *b;&lt;/p&gt;
&lt;p&gt;我
      
    
    </summary>
    
    
      <category term="C++和汇编" scheme="http://yoursite.com/tags/C-%E5%92%8C%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
</feed>
